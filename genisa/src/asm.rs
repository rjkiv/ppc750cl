use crate::condition::{parse_conditions, replace_fields, ConditionOp, ConditionValue};
use crate::isa::{
    modifiers_iter, modifiers_valid, to_ident, Field, HexLiteral, Isa, Mnemonic, Opcode,
    SignedHexLiteral,
};
use anyhow::{bail, Context, Result};
use proc_macro2::{Literal, TokenStream};
use quote::{format_ident, quote};
use std::collections::BTreeMap;

enum OpcodeOrMnemonic {
    Opcode(Opcode),
    Mnemonic(Mnemonic),
}

impl OpcodeOrMnemonic {
    fn name(&self) -> &str {
        match self {
            OpcodeOrMnemonic::Opcode(opcode) => &opcode.name,
            OpcodeOrMnemonic::Mnemonic(mnemonic) => &mnemonic.name,
        }
    }
}

pub fn gen_asm(isa: &Isa, max_args: usize) -> Result<TokenStream> {
    let mut functions = TokenStream::new();

    let mut func_map = phf_codegen::Map::new();
    let mut mnemonic_map = BTreeMap::<String, Vec<OpcodeOrMnemonic>>::new();
    for opcode in &isa.opcodes {
        mnemonic_map
            .entry(opcode.name.clone())
            .or_default()
            .push(OpcodeOrMnemonic::Opcode(opcode.clone()));
    }
    for mnemonic in &isa.mnemonics {
        mnemonic_map
            .entry(mnemonic.name.clone())
            .or_default()
            .push(OpcodeOrMnemonic::Mnemonic(mnemonic.clone()));
    }
    for (name, mnemonics) in &mnemonic_map {
        let fn_name = format!("gen_{}", to_ident(name));
        let fn_ident = format_ident!("{}", fn_name);
        let mut inner;
        if mnemonics.len() > 1 {
            inner = TokenStream::new();
            let mut max_args = 0;
            for mnemonic in mnemonics {
                let (gen, args_len) = match mnemonic {
                    OpcodeOrMnemonic::Opcode(opcode) => {
                        (gen_opcode(opcode, isa, false)?, opcode.args.len())
                    }
                    OpcodeOrMnemonic::Mnemonic(mnemonic) => {
                        (gen_mnemonic(mnemonic, isa, false)?, mnemonic.args.len())
                    }
                };
                let arg_n = Literal::usize_unsuffixed(args_len);
                inner.extend(quote! {
                    #arg_n => { #gen }
                });
                max_args = max_args.max(args_len);
            }
            let max_args = Literal::usize_unsuffixed(max_args);
            inner.extend(quote! {
                value => Err(ArgumentError::ArgCount { value, expected: #max_args })
            });
            inner = quote! { match arg_count(args) { #inner } };
        } else {
            inner = match mnemonics.first().unwrap() {
                OpcodeOrMnemonic::Opcode(opcode) => gen_opcode(opcode, isa, true)?,
                OpcodeOrMnemonic::Mnemonic(mnemonic) => gen_mnemonic(mnemonic, isa, true)?,
            };
        }
        functions.extend(quote! {
            fn #fn_ident(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> { #inner }
        });
    }

    for (mnemonic, modifiers) in mnemonic_map.iter().flat_map(|(_, mnemonics)| {
        let mnemonic = mnemonics.first().unwrap();
        let modifiers = match mnemonic {
            OpcodeOrMnemonic::Opcode(opcode) => &opcode.modifiers,
            OpcodeOrMnemonic::Mnemonic(mnemonic) => {
                let opcode = isa.find_opcode(&mnemonic.opcode).unwrap();
                mnemonic.modifiers.as_deref().unwrap_or(&opcode.modifiers)
            }
        };
        modifiers_iter(modifiers, isa).filter(|m| modifiers_valid(m)).map(move |m| (mnemonic, m))
    }) {
        let suffix = modifiers.iter().map(|m| m.suffix).collect::<String>();
        let mut pattern = 0;
        for modifier in &modifiers {
            pattern |= modifier.mask();
        }
        let name = format!("{}{}", mnemonic.name(), suffix);
        func_map.entry(name, &format!("(gen_{}, {:#x})", to_ident(mnemonic.name()), pattern));
    }

    let func_map = syn::parse_str::<TokenStream>(&func_map.build().to_string())?;
    let max_args = Literal::usize_unsuffixed(max_args);
    Ok(quote! {
        #![allow(unused)]
        #![cfg_attr(rustfmt, rustfmt_skip)]
        #[comment = " Code generated by ppc750-genisa. DO NOT EDIT."]
        use crate::types::*;
        pub type Arguments = [Argument; #max_args];
        #functions
        type MnemonicFn = fn(&Arguments, u32) -> Result<u32, ArgumentError>;
        static MNEMONIC_MAP: phf::Map<&'static str, (MnemonicFn, u32)> = #func_map;
        pub fn assemble(mnemonic: &str, args: &Arguments) -> Result<u32, ArgumentError> {
            if let Some(&(fn_ptr, modifiers)) = MNEMONIC_MAP.get(mnemonic) {
                fn_ptr(args, modifiers)
            } else {
                Err(ArgumentError::UnknownMnemonic)
            }
        }
    })
}

fn gen_parse_field(field: &Field, i: usize) -> Result<(TokenStream, bool)> {
    let Some(bits) = &field.bits else { bail!("Field {} has no bits", field.name) };
    let i = Literal::usize_unsuffixed(i);
    Ok(if field.signed {
        let max_value = 1 << (bits.len() - 1 + field.shift_left);
        let min_value = SignedHexLiteral(-max_value);
        let max_value = SignedHexLiteral(max_value);
        (quote! { parse_signed(args, #i, #min_value, #max_value)? }, true)
    } else {
        let min_value = HexLiteral(0);
        let max_value = HexLiteral(bits.max_value() << field.shift_left);
        (quote! { parse_unsigned(args, #i, #min_value, #max_value)? }, false)
    })
}

fn gen_field(field: &Field, mut accessor: TokenStream, signed: bool) -> Result<TokenStream> {
    let Some(bits) = &field.bits else { bail!("Field {} has no bits", field.name) };

    // Optimization: offset all shifts to avoid unnecessary operations
    let shift_offset = field.shift_left.min(bits.shift());

    // Handle the operations (in reverse order from disassembly)
    let mut operations = TokenStream::new();
    if signed {
        accessor = quote! { #accessor as u32 };
    }

    let mut bit_position = 0;
    for range in bits.0.iter().rev() {
        let mut shift_right = range.shift() - shift_offset;
        let mut shift_left = field.shift_left + bit_position - shift_offset;

        // Optimize shifts
        let common_shift = shift_right.min(shift_left);
        shift_right -= common_shift;
        shift_left -= common_shift;

        // Shift left
        let mut inner = if shift_left > 0 {
            let shift_left = Literal::u8_unsuffixed(shift_left);
            quote! { (arg >> #shift_left) }
        } else {
            quote! { arg }
        };

        // Mask
        let mask = HexLiteral(range.mask() >> shift_right);
        inner = quote! { #inner & #mask };

        // Shift right
        if shift_right > 0 {
            let shift_right = Literal::u8_unsuffixed(shift_right);
            inner = quote! { (#inner) << #shift_right };
        }

        bit_position += range.len();
        operations.extend(quote! {
            code |= #inner;
        });
    }

    Ok(quote! {{
        let arg = #accessor;
        #operations
    }})
}

fn gen_opcode(opcode: &Opcode, isa: &Isa, check_arg_count: bool) -> Result<TokenStream> {
    let mut args = TokenStream::new();
    for (i, arg) in opcode.args.iter().enumerate() {
        let field = isa.find_field(arg).unwrap();
        let comment = format!(" {}", field.name);
        let (accessor, signed) = gen_parse_field(field, i)?;
        let operations = gen_field(field, accessor, signed)?;
        args.extend(quote! {
            #[comment = #comment]
            #operations
        });
    }

    let arg_count = Literal::usize_unsuffixed(opcode.args.len());
    let mut result = TokenStream::new();
    if check_arg_count {
        result.extend(quote! { check_arg_count(args, #arg_count)?; });
    }

    let pattern = HexLiteral(opcode.pattern);
    result.extend(quote! {
        let mut code = #pattern | modifiers;
        #args
        Ok(code)
    });
    Ok(result)
}

fn gen_mnemonic(mnemonic: &Mnemonic, isa: &Isa, check_arg_count: bool) -> Result<TokenStream> {
    let Some(opcode) = isa.find_opcode(&mnemonic.opcode) else {
        bail!("Unknown opcode {}", mnemonic.opcode)
    };
    let mut args = TokenStream::new();
    for (i, arg) in mnemonic.args.iter().enumerate() {
        let comment = format!(" {arg}");
        let operations = gen_argument(&mnemonic.args, i, isa, mnemonic.replace_assemble.get(arg))?;
        args.extend(quote! {
            #[comment = #comment]
            #operations
        });
    }

    let mut pattern = opcode.pattern;
    for condition in parse_conditions(&mnemonic.condition, isa)? {
        if condition.op == ConditionOp::Eq {
            match condition.value {
                ConditionValue::ConstantUnsigned(value) => {
                    pattern |= condition.field.shift_value(value);
                }
                ConditionValue::ConstantSigned(value) => {
                    pattern |= condition.field.shift_value(value as u32);
                }
                ConditionValue::Field(in_field) => {
                    let comment = format!(" {}", condition.field.name);
                    let arg_n = mnemonic
                        .args
                        .iter()
                        .position(|a| a == &in_field.name)
                        .with_context(|| {
                            format!("Mnemonic {}: unknown field {}", mnemonic.name, in_field.name)
                        })?;
                    let (accessor, signed) = gen_parse_field(in_field, arg_n)?;
                    let operations = gen_field(condition.field, accessor, signed)?;
                    args.extend(quote! {
                        #[comment = #comment]
                        #operations
                    });
                }
                ConditionValue::Complex(c) => {
                    let comment = format!(" {}", condition.field.name);
                    let mut any_signed = false;
                    let arg = replace_fields(c, isa, |f| {
                        let arg_n =
                            mnemonic.args.iter().position(|a| a == &f.name).with_context(|| {
                                format!("Mnemonic {}: unknown field {}", mnemonic.name, f.name)
                            })?;
                        let (s, signed) = gen_parse_field(f, arg_n)?;
                        any_signed |= signed;
                        Ok(s)
                    })?;
                    let operations = gen_field(condition.field, quote! { (#arg) }, any_signed)?;
                    args.extend(quote! {
                        #[comment = #comment]
                        #operations
                    });
                }
            }
        }
    }

    let arg_count = Literal::usize_unsuffixed(mnemonic.args.len());
    let mut result = TokenStream::new();
    if check_arg_count {
        result.extend(quote! { check_arg_count(args, #arg_count)?; });
    }

    let pattern = HexLiteral(pattern);
    result.extend(quote! {
        let mut code = #pattern | modifiers;
        #args
        Ok(code)
    });
    Ok(result)
}

fn gen_argument(
    args: &[String],
    arg_n: usize,
    isa: &Isa,
    replace: Option<&String>,
) -> Result<TokenStream> {
    let field = &args[arg_n];
    let Some(field) = isa.find_field(field) else { bail!("Unknown field {}", field) };
    if let Some(replace) = replace {
        let mut any_signed = false;
        let stream = replace_fields(replace, isa, |f| {
            let arg_n = args.iter().position(|a| a == &f.name).with_context(|| {
                format!("Field {} references unknown argument {}", field.name, f.name)
            })?;
            let (parse, signed) = gen_parse_field(field, arg_n)?;
            any_signed |= signed;
            Ok(parse)
        })?;
        gen_field(field, quote! { (#stream) }, any_signed)
    } else {
        let (accessor, signed) = gen_parse_field(field, arg_n)?;
        gen_field(field, accessor, signed)
    }
}
