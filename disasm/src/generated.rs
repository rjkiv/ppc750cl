#![allow(unused)]
#![cfg_attr(rustfmt, rustfmt_skip)]
// Code generated by ppc750-genisa. DO NOT EDIT.
use crate::disasm::*;
/// The entry table allows us to quickly find the range of possible opcodes for a
/// given 6-bit prefix. 2*64 bytes should fit in a cache line (or two).
static OPCODE_ENTRIES: [(u16, u16); 64] = [
    (0, 0),
    (0, 0),
    (0, 1),
    (1, 2),
    (2, 147),
    (0, 0),
    (0, 0),
    (147, 148),
    (148, 149),
    (0, 0),
    (149, 150),
    (150, 151),
    (151, 152),
    (152, 153),
    (153, 154),
    (154, 155),
    (155, 156),
    (156, 157),
    (157, 158),
    (158, 172),
    (172, 173),
    (173, 174),
    (0, 0),
    (174, 175),
    (175, 176),
    (176, 177),
    (177, 178),
    (178, 179),
    (179, 180),
    (180, 181),
    (181, 187),
    (187, 319),
    (319, 320),
    (320, 321),
    (321, 322),
    (322, 323),
    (323, 324),
    (324, 325),
    (325, 326),
    (326, 327),
    (327, 328),
    (328, 329),
    (329, 330),
    (330, 331),
    (331, 332),
    (332, 333),
    (333, 334),
    (334, 335),
    (335, 336),
    (336, 337),
    (337, 338),
    (338, 339),
    (339, 340),
    (340, 341),
    (341, 342),
    (342, 343),
    (0, 0),
    (0, 0),
    (343, 346),
    (346, 355),
    (0, 0),
    (0, 0),
    (355, 357),
    (357, 385),
];
/// The bitmask and pattern for each opcode.
static OPCODE_PATTERNS: [(u32, u32); 512] = [
    (0xfc000000, 0x8000000),
    (0xfc000000, 0xc000000),
    (0xffe007ff, 0x100007ec),
    (0xfc1fffff, 0x10000604),
    (0xffff07ff, 0x10000c44),
    (0xfc0007ff, 0x10000180),
    (0xfc0007ff, 0x1000000a),
    (0xfc0007ff, 0x10000300),
    (0xfc0007ff, 0x10000340),
    (0xfc0007ff, 0x10000380),
    (0xfc0007ff, 0x10000000),
    (0xfc0007ff, 0x10000200),
    (0xfc0007ff, 0x10000040),
    (0xfc0007ff, 0x10000240),
    (0xfc0007ff, 0x10000080),
    (0xfc0007ff, 0x10000280),
    (0xfc0007ff, 0x10000404),
    (0xfc0007ff, 0x10000444),
    (0xfc0007ff, 0x10000502),
    (0xfc0007ff, 0x10000542),
    (0xfc0007ff, 0x10000582),
    (0xfc0007ff, 0x10000402),
    (0xfc0007ff, 0x10000442),
    (0xfc0007ff, 0x10000482),
    (0xfc0007ff, 0x1000034a),
    (0xfc0007ff, 0x1000030a),
    (0xfc0007fe, 0x100003c6),
    (0xfc0007fe, 0x100000c6),
    (0xfc0007fe, 0x10000006),
    (0xfc0007fe, 0x10000046),
    (0xfc0007fe, 0x10000086),
    (0xfc0007fe, 0x100001c6),
    (0xfc0007fe, 0x100002c6),
    (0xfc0007fe, 0x10000306),
    (0xfc0007fe, 0x10000346),
    (0xfc0007fe, 0x10000386),
    (0xfc0007fe, 0x10000206),
    (0xfc0007fe, 0x10000246),
    (0xfc0007fe, 0x10000286),
    (0xfc0007ff, 0x100003ca),
    (0xfc0007ff, 0x1000038a),
    (0xfc1f07ff, 0x1000018a),
    (0xfc1f07ff, 0x100001ca),
    (0xfc00003f, 0x1000002e),
    (0xfc0007ff, 0x1000040a),
    (0xfc0007ff, 0x10000102),
    (0xfc0007ff, 0x10000142),
    (0xfc0007ff, 0x10000182),
    (0xfc0007ff, 0x10000002),
    (0xfc0007ff, 0x10000042),
    (0xfc0007ff, 0x10000082),
    (0xfc00003f, 0x10000020),
    (0xfc00003f, 0x10000021),
    (0xfc0007ff, 0x1000044a),
    (0xfc0007ff, 0x10000302),
    (0xfc0007ff, 0x10000342),
    (0xfc0007ff, 0x10000382),
    (0xfc0007ff, 0x10000202),
    (0xfc0007ff, 0x10000242),
    (0xfc0007ff, 0x10000282),
    (0xfc00003f, 0x10000022),
    (0xfc0007ff, 0x1000000c),
    (0xfc0007ff, 0x1000004c),
    (0xfc0007ff, 0x1000008c),
    (0xfc0007ff, 0x1000010c),
    (0xfc0007ff, 0x1000014c),
    (0xfc0007ff, 0x1000018c),
    (0xfc00003f, 0x10000025),
    (0xfc00003f, 0x10000028),
    (0xfc00003f, 0x10000029),
    (0xfc00003f, 0x10000024),
    (0xfc00003f, 0x10000026),
    (0xfc00003f, 0x10000027),
    (0xfc0007ff, 0x10000308),
    (0xfc0007ff, 0x10000348),
    (0xfc0007ff, 0x10000208),
    (0xfc0007ff, 0x10000248),
    (0xfc0007ff, 0x10000108),
    (0xfc0007ff, 0x10000148),
    (0xfc0007ff, 0x10000008),
    (0xfc0007ff, 0x10000048),
    (0xfc00003f, 0x1000002f),
    (0xfc0007ff, 0x10000504),
    (0xfc0007ff, 0x10000484),
    (0xfc00003f, 0x1000002b),
    (0xfc0007ff, 0x1000030e),
    (0xfc0007ff, 0x1000018e),
    (0xfc0007ff, 0x1000010e),
    (0xfc0007ff, 0x100001ce),
    (0xfc0007ff, 0x1000014e),
    (0xfc0007ff, 0x1000000e),
    (0xfc0007ff, 0x1000008e),
    (0xfc0007ff, 0x1000004e),
    (0xfc0007ff, 0x100000ce),
    (0xfc1f07ff, 0x1000010a),
    (0xfc1f07ff, 0x100002ca),
    (0xfc1f07ff, 0x1000020a),
    (0xfc1f07ff, 0x1000028a),
    (0xfc1f07ff, 0x1000024a),
    (0xfc0007ff, 0x10000004),
    (0xfc0007ff, 0x10000044),
    (0xfc0007ff, 0x10000084),
    (0xfc1f07ff, 0x1000014a),
    (0xfc00003f, 0x1000002a),
    (0xfc0007ff, 0x100001c4),
    (0xfc0007ff, 0x10000104),
    (0xfc00043f, 0x1000002c),
    (0xfc0007ff, 0x10000144),
    (0xfc0007ff, 0x1000040c),
    (0xfc0007ff, 0x10000184),
    (0xfc0007ff, 0x1000020c),
    (0xfc0007ff, 0x1000024c),
    (0xfc00ffff, 0x1000030c),
    (0xfc00ffff, 0x1000034c),
    (0xfc00ffff, 0x1000038c),
    (0xfc0007ff, 0x1000028c),
    (0xfc0007ff, 0x100002c4),
    (0xfc0007ff, 0x10000304),
    (0xfc0007ff, 0x10000344),
    (0xfc0007ff, 0x10000384),
    (0xfc0007ff, 0x10000204),
    (0xfc0007ff, 0x10000244),
    (0xfc0007ff, 0x1000044c),
    (0xfc0007ff, 0x10000284),
    (0xfc0007ff, 0x10000580),
    (0xfc0007ff, 0x1000004a),
    (0xfc0007ff, 0x10000700),
    (0xfc0007ff, 0x10000740),
    (0xfc0007ff, 0x10000780),
    (0xfc0007ff, 0x10000400),
    (0xfc0007ff, 0x10000600),
    (0xfc0007ff, 0x10000440),
    (0xfc0007ff, 0x10000640),
    (0xfc0007ff, 0x10000480),
    (0xfc0007ff, 0x10000680),
    (0xfc0007ff, 0x10000788),
    (0xfc0007ff, 0x10000688),
    (0xfc0007ff, 0x10000708),
    (0xfc0007ff, 0x10000648),
    (0xfc0007ff, 0x10000608),
    (0xfc1f07ff, 0x1000034e),
    (0xfc1f07ff, 0x1000020e),
    (0xfc1f07ff, 0x1000024e),
    (0xfc1f07ff, 0x100003ce),
    (0xfc1f07ff, 0x1000028e),
    (0xfc1f07ff, 0x100002ce),
    (0xfc0007ff, 0x100004c4),
    (0xfc000000, 0x1c000000),
    (0xfc000000, 0x20000000),
    (0xfc400000, 0x28000000),
    (0xfc400000, 0x2c000000),
    (0xfc000000, 0x30000000),
    (0xfc000000, 0x34000000),
    (0xfc000000, 0x38000000),
    (0xfc000000, 0x3c000000),
    (0xfc000000, 0x40000000),
    (0xffffffff, 0x44000002),
    (0xfc000000, 0x48000000),
    (0xfc00fffe, 0x4c000420),
    (0xfc00fffe, 0x4c000020),
    (0xfc0007ff, 0x4c000202),
    (0xfc0007ff, 0x4c000102),
    (0xfc0007ff, 0x4c000242),
    (0xfc0007ff, 0x4c0001c2),
    (0xfc0007ff, 0x4c000042),
    (0xfc0007ff, 0x4c000382),
    (0xfc0007ff, 0x4c000342),
    (0xfc0007ff, 0x4c000182),
    (0xffffffff, 0x4c00012c),
    (0xfc63ffff, 0x4c000000),
    (0xffffffff, 0x4c000064),
    (0xffffffff, 0x4c000024),
    (0xfc000000, 0x50000000),
    (0xfc000000, 0x54000000),
    (0xfc000000, 0x5c000000),
    (0xfc000000, 0x60000000),
    (0xfc000000, 0x64000000),
    (0xfc000000, 0x68000000),
    (0xfc000000, 0x6c000000),
    (0xfc000000, 0x70000000),
    (0xfc000000, 0x74000000),
    (0xfc00003e, 0x78000010),
    (0xfc0007c0, 0x78000012),
    (0xfc00003e, 0x78000008),
    (0xfc00003e, 0x78000000),
    (0xfc0007c0, 0x78000004),
    (0xfc00003e, 0x7800000c),
    (0xfc0003fe, 0x7c000214),
    (0xfc0003fe, 0x7c000014),
    (0xfc0003fe, 0x7c000114),
    (0xfc00fbfe, 0x7c0001d4),
    (0xfc00fbfe, 0x7c000194),
    (0xfc0007fe, 0x7c000038),
    (0xfc0007fe, 0x7c000078),
    (0xfc4007ff, 0x7c000000),
    (0xfc4007ff, 0x7c000040),
    (0xfc00fffe, 0x7c000074),
    (0xfc00fffe, 0x7c000034),
    (0xffe007ff, 0x7c0000ac),
    (0xffe007ff, 0x7c0003ac),
    (0xffe007ff, 0x7c00006c),
    (0xffe007ff, 0x7c00022c),
    (0xffe007ff, 0x7c0001ec),
    (0xffe007ff, 0x7c0007ec),
    (0xfc0003fe, 0x7c0003d2),
    (0xfc0003fe, 0x7c000392),
    (0xfc0003fe, 0x7c0003d6),
    (0xfc0003fe, 0x7c000396),
    (0xfc0007ff, 0x7c00026c),
    (0xfc0007ff, 0x7c00036c),
    (0xffffffff, 0x7c0006ac),
    (0xfc0007fe, 0x7c000238),
    (0xfc00fffe, 0x7c000774),
    (0xfc00fffe, 0x7c000734),
    (0xfc00fffe, 0x7c0007b4),
    (0xffe007fe, 0x7c0007ac),
    (0xfc0007ff, 0x7c0000ee),
    (0xfc0007ff, 0x7c0000ae),
    (0xfc0007ff, 0x7c0000a8),
    (0xfc0007ff, 0x7c00006a),
    (0xfc0007ff, 0x7c00002a),
    (0xfc0007ff, 0x7c0004ee),
    (0xfc0007ff, 0x7c0004ae),
    (0xfc0007ff, 0x7c00046e),
    (0xfc0007ff, 0x7c00042e),
    (0xfc0007ff, 0x7c0002ee),
    (0xfc0007ff, 0x7c0002ae),
    (0xfc0007ff, 0x7c00062c),
    (0xfc0007ff, 0x7c00026e),
    (0xfc0007ff, 0x7c00022e),
    (0xfc0007ff, 0x7c0004aa),
    (0xfc0007ff, 0x7c00042a),
    (0xfc0007ff, 0x7c000028),
    (0xfc0007ff, 0x7c0002ea),
    (0xfc0007ff, 0x7c0002aa),
    (0xfc0007ff, 0x7c00042c),
    (0xfc0007ff, 0x7c00006e),
    (0xfc0007ff, 0x7c00002e),
    (0xfc7fffff, 0x7c000400),
    (0xfc1fffff, 0x7c000026),
    (0xfc1fffff, 0x7c0000a6),
    (0xfc0007ff, 0x7c0002a6),
    (0xfc10ffff, 0x7c0004a6),
    (0xfc1f07ff, 0x7c000526),
    (0xfc0007ff, 0x7c0002e6),
    (0xfc100fff, 0x7c000120),
    (0xfc1fffff, 0x7c000124),
    (0xfc1fffff, 0x7c000164),
    (0xfc0007ff, 0x7c0003a6),
    (0xfc10ffff, 0x7c0001a4),
    (0xfc10ffff, 0x7c0000a4),
    (0xfc1f07ff, 0x7c0000e4),
    (0xfc1f07ff, 0x7c0001e4),
    (0xfc0007fe, 0x7c000092),
    (0xfc0007fe, 0x7c000012),
    (0xfc0007fe, 0x7c000096),
    (0xfc0007fe, 0x7c000016),
    (0xfc0003fe, 0x7c0001d2),
    (0xfc0003fe, 0x7c0001d6),
    (0xfc0007fe, 0x7c0003b8),
    (0xfc00fbfe, 0x7c0000d0),
    (0xfc0007fe, 0x7c0000f8),
    (0xfc0007fe, 0x7c000378),
    (0xfc0007fe, 0x7c000338),
    (0xffffffff, 0x7c0003e4),
    (0xffff07ff, 0x7c000364),
    (0xfc0007fe, 0x7c000036),
    (0xfc0007fe, 0x7c000030),
    (0xfc0007fe, 0x7c000634),
    (0xfc0007fe, 0x7c000674),
    (0xfc0007fe, 0x7c000630),
    (0xfc0007fe, 0x7c000670),
    (0xfc0007fe, 0x7c000436),
    (0xfc0007fe, 0x7c000430),
    (0xfc0007ff, 0x7c0001ee),
    (0xfc0007ff, 0x7c0001ae),
    (0xfc0007ff, 0x7c0001ad),
    (0xfc0007ff, 0x7c00016a),
    (0xfc0007ff, 0x7c00012a),
    (0xfc0007ff, 0x7c0005ee),
    (0xfc0007ff, 0x7c0005ae),
    (0xfc0007ff, 0x7c0007ae),
    (0xfc0007ff, 0x7c00056e),
    (0xfc0007ff, 0x7c00052e),
    (0xfc0007ff, 0x7c00072c),
    (0xfc0007ff, 0x7c00036e),
    (0xfc0007ff, 0x7c00032e),
    (0xfc0007ff, 0x7c0005aa),
    (0xfc0007ff, 0x7c00052a),
    (0xfc0007ff, 0x7c00052c),
    (0xfc0007ff, 0x7c00012d),
    (0xfc0007ff, 0x7c00016e),
    (0xfc0007ff, 0x7c00012e),
    (0xfc0003fe, 0x7c000050),
    (0xfc0003fe, 0x7c000010),
    (0xfc0003fe, 0x7c000110),
    (0xfc00fbfe, 0x7c0001d0),
    (0xfc00fbfe, 0x7c000190),
    (0xffffffff, 0x7c0004ac),
    (0xfc0007ff, 0x7c000088),
    (0xffff07ff, 0x7c000264),
    (0xffffffff, 0x7c00046c),
    (0xfc0007ff, 0x7c000008),
    (0xfc0007fe, 0x7c000278),
    (0xfd9fffff, 0x7c00066c),
    (0xfd8007ff, 0x7c0002ac),
    (0xfd8007ff, 0x7c0002ec),
    (0xfc0007ff, 0x7c00000e),
    (0xfc0007ff, 0x7c00004e),
    (0xfc0007ff, 0x7c00008e),
    (0xfc0007ff, 0x7c00000c),
    (0xfc0007ff, 0x7c00004c),
    (0xfc0007ff, 0x7c0000ce),
    (0xfc0007ff, 0x7c0002ce),
    (0xfc0007ff, 0x7c00010e),
    (0xfc0007ff, 0x7c00014e),
    (0xfc0007ff, 0x7c00018e),
    (0xfc0007ff, 0x7c0001ce),
    (0xfc0007ff, 0x7c0003ce),
    (0xfc000000, 0x80000000),
    (0xfc000000, 0x84000000),
    (0xfc000000, 0x88000000),
    (0xfc000000, 0x8c000000),
    (0xfc000000, 0x90000000),
    (0xfc000000, 0x94000000),
    (0xfc000000, 0x98000000),
    (0xfc000000, 0x9c000000),
    (0xfc000000, 0xa0000000),
    (0xfc000000, 0xa4000000),
    (0xfc000000, 0xa8000000),
    (0xfc000000, 0xac000000),
    (0xfc000000, 0xb0000000),
    (0xfc000000, 0xb4000000),
    (0xfc000000, 0xb8000000),
    (0xfc000000, 0xbc000000),
    (0xfc000000, 0xc0000000),
    (0xfc000000, 0xc4000000),
    (0xfc000000, 0xc8000000),
    (0xfc000000, 0xcc000000),
    (0xfc000000, 0xd0000000),
    (0xfc000000, 0xd4000000),
    (0xfc000000, 0xd8000000),
    (0xfc000000, 0xdc000000),
    (0xfc000000, 0xe8000000),
    (0xfc000000, 0xe8000001),
    (0xfc000000, 0xe8000002),
    (0xfc0007fe, 0xec00002a),
    (0xfc0007fe, 0xec000024),
    (0xfc00003e, 0xec00003a),
    (0xfc00003e, 0xec000038),
    (0xfc00f83e, 0xec000032),
    (0xfc00003e, 0xec00003e),
    (0xfc00003e, 0xec00003c),
    (0xfc1f07fe, 0xec000030),
    (0xfc0007fe, 0xec000028),
    (0xfc000000, 0xf8000000),
    (0xfc000000, 0xf8000001),
    (0xfc1f07fe, 0xfc000210),
    (0xfc0007fe, 0xfc00002a),
    (0xfc1f07fe, 0xfc00069c),
    (0xfc6007ff, 0xfc000040),
    (0xfc6007ff, 0xfc000000),
    (0xfc1f07fe, 0xfc00065c),
    (0xfc1f07fe, 0xfc00065e),
    (0xfc1f07fe, 0xfc00001c),
    (0xfc1f07fe, 0xfc00001e),
    (0xfc0007fe, 0xfc000024),
    (0xfc00003e, 0xfc00003a),
    (0xfc1f07fe, 0xfc000090),
    (0xfc00003e, 0xfc000038),
    (0xfc00f83e, 0xfc000032),
    (0xfc1f07fe, 0xfc000110),
    (0xfc1f07fe, 0xfc000050),
    (0xfc00003e, 0xfc00003e),
    (0xfc00003e, 0xfc00003c),
    (0xfc1f07fe, 0xfc000018),
    (0xfc1f07fe, 0xfc000034),
    (0xfc00003e, 0xfc00002e),
    (0xfc0007fe, 0xfc000028),
    (0xfc63ffff, 0xfc000080),
    (0xfc1ffffe, 0xfc00048e),
    (0xfc1ffffe, 0xfc00008c),
    (0xfc1ffffe, 0xfc00004c),
    (0xfe0107fe, 0xfc00058e),
    (0xfc7f0ffe, 0xfc00010c),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
];
/// The name of each opcode.
static OPCODE_NAMES: [&str; 512] = [
    "tdwi",
    "twi",
    "dcbz_l",
    "mfvscr",
    "mtvscr",
    "vaddcuw",
    "vaddfp",
    "vaddsbs",
    "vaddshs",
    "vaddsws",
    "vaddubm",
    "vaddubs",
    "vadduhm",
    "vadduhs",
    "vadduwm",
    "vadduws",
    "vand",
    "vandc",
    "vavgsb",
    "vavgsh",
    "vavgsw",
    "vavgub",
    "vavguh",
    "vavguw",
    "vcfsx",
    "vcfux",
    "vcmpbfp",
    "vcmpeqfp",
    "vcmpequb",
    "vcmpequh",
    "vcmpequw",
    "vcmpgefp",
    "vcmpgtfp",
    "vcmpgtsb",
    "vcmpgtsh",
    "vcmpgtsw",
    "vcmpgtub",
    "vcmpgtuh",
    "vcmpgtuw",
    "vctsxs",
    "vctuxs",
    "vexptefp",
    "vlogefp",
    "vmaddfp",
    "vmaxfp",
    "vmaxsb",
    "vmaxsh",
    "vmaxsw",
    "vmaxub",
    "vmaxuh",
    "vmaxuw",
    "vmhaddshs",
    "vmhraddshs",
    "vminfp",
    "vminsb",
    "vminsh",
    "vminsw",
    "vminub",
    "vminuh",
    "vminuw",
    "vmladduhm",
    "vmrghb",
    "vmrghh",
    "vmrghw",
    "vmrglb",
    "vmrglh",
    "vmrglw",
    "vmsummbm",
    "vmsumshm",
    "vmsumshs",
    "vmsumubm",
    "vmsumuhm",
    "vmsumuhs",
    "vmulesb",
    "vmulesh",
    "vmuleub",
    "vmuleuh",
    "vmulosb",
    "vmulosh",
    "vmuloub",
    "vmulouh",
    "vnmsubfp",
    "vnor",
    "vor",
    "vperm",
    "vpkpx",
    "vpkshss",
    "vpkshus",
    "vpkswss",
    "vpkswus",
    "vpkuhum",
    "vpkuhus",
    "vpkuwum",
    "vpkuwus",
    "vrefp",
    "vrfim",
    "vrfin",
    "vrfip",
    "vrfiz",
    "vrlb",
    "vrlh",
    "vrlw",
    "vrsqrtefp",
    "vsel",
    "vsl",
    "vslb",
    "vsldoi",
    "vslh",
    "vslo",
    "vslw",
    "vspltb",
    "vsplth",
    "vspltisb",
    "vspltish",
    "vspltisw",
    "vspltw",
    "vsr",
    "vsrab",
    "vsrah",
    "vsraw",
    "vsrb",
    "vsrh",
    "vsro",
    "vsrw",
    "vsubcuw",
    "vsubfp",
    "vsubsbs",
    "vsubshs",
    "vsubsws",
    "vsububm",
    "vsububs",
    "vsubuhm",
    "vsubuhs",
    "vsubuwm",
    "vsubuws",
    "vsumsws",
    "vsum2sws",
    "vsum4sbs",
    "vsum4shs",
    "vsum4ubs",
    "vupkhpx",
    "vupkhsb",
    "vupkhsh",
    "vupklpx",
    "vupklsb",
    "vupklsh",
    "vxor",
    "mulli",
    "subfic",
    "cmpli",
    "cmpi",
    "addic",
    "addic.",
    "addi",
    "addis",
    "bc",
    "sc",
    "b",
    "bcctr",
    "bclr",
    "crand",
    "crandc",
    "creqv",
    "crnand",
    "crnor",
    "cror",
    "crorc",
    "crxor",
    "isync",
    "mcrf",
    "rfi",
    "rfid",
    "rlwimi",
    "rlwinm",
    "rlwnm",
    "ori",
    "oris",
    "xori",
    "xoris",
    "andi.",
    "andis.",
    "rldcl",
    "rldcr",
    "rldic",
    "rldicl",
    "rldicr",
    "rldimi",
    "add",
    "addc",
    "adde",
    "addme",
    "addze",
    "and",
    "andc",
    "cmp",
    "cmpl",
    "cntlzd",
    "cntlzw",
    "dcbf",
    "dcbi",
    "dcbst",
    "dcbt",
    "dcbtst",
    "dcbz",
    "divd",
    "divdu",
    "divw",
    "divwu",
    "eciwx",
    "ecowx",
    "eieio",
    "eqv",
    "extsb",
    "extsh",
    "extsw",
    "icbi",
    "lbzux",
    "lbzx",
    "ldarx",
    "ldux",
    "ldx",
    "lfdux",
    "lfdx",
    "lfsux",
    "lfsx",
    "lhaux",
    "lhax",
    "lhbrx",
    "lhzux",
    "lhzx",
    "lswi",
    "lswx",
    "lwarx",
    "lwaux",
    "lwax",
    "lwbrx",
    "lwzux",
    "lwzx",
    "mcrxr",
    "mfcr",
    "mfmsr",
    "mfspr",
    "mfsr",
    "mfsrin",
    "mftb",
    "mtcrf",
    "mtmsr",
    "mtmsrd",
    "mtspr",
    "mtsr",
    "mtsrd",
    "mtsrdin",
    "mtsrin",
    "mulhd",
    "mulhdu",
    "mulhw",
    "mulhwu",
    "mulld",
    "mullw",
    "nand",
    "neg",
    "nor",
    "or",
    "orc",
    "slbia",
    "slbie",
    "sld",
    "slw",
    "srad",
    "sradi",
    "sraw",
    "srawi",
    "srd",
    "srw",
    "stbux",
    "stbx",
    "stdcx",
    "stdux",
    "stdx",
    "stfdux",
    "stfdx",
    "stfiwx",
    "stfsux",
    "stfsx",
    "sthbrx",
    "sthux",
    "sthx",
    "stswi",
    "stswx",
    "stwbrx",
    "stwcx.",
    "stwux",
    "stwx",
    "subf",
    "subfc",
    "subfe",
    "subfme",
    "subfze",
    "sync",
    "td",
    "tlbie",
    "tlbsync",
    "tw",
    "xor",
    "dss",
    "dst",
    "dstst",
    "lvebx",
    "lvehx",
    "lvewx",
    "lvsl",
    "lvsr",
    "lvx",
    "lvxl",
    "stvebx",
    "stvehx",
    "stvewx",
    "stvx",
    "stvxl",
    "lwz",
    "lwzu",
    "lbz",
    "lbzu",
    "stw",
    "stwu",
    "stb",
    "stbu",
    "lhz",
    "lhzu",
    "lha",
    "lhau",
    "sth",
    "sthu",
    "lmw",
    "stmw",
    "lfs",
    "lfsu",
    "lfd",
    "lfdu",
    "stfs",
    "stfsu",
    "stfd",
    "stfdu",
    "ld",
    "ldu",
    "lwa",
    "fadds",
    "fdivs",
    "fmadds",
    "fmsubs",
    "fmuls",
    "fnmadds",
    "fnmsubs",
    "fres",
    "fsubs",
    "std",
    "stdu",
    "fabs",
    "fadd",
    "fcfid",
    "fcmpo",
    "fcmpu",
    "fctid",
    "fctidz",
    "fctiw",
    "fctiwz",
    "fdiv",
    "fmadd",
    "fmr",
    "fmsub",
    "fmul",
    "fnabs",
    "fneg",
    "fnmadd",
    "fnmsub",
    "frsp",
    "frsqrte",
    "fsel",
    "fsub",
    "mcrfs",
    "mffs",
    "mtfsb0",
    "mtfsb1",
    "mtfsf",
    "mtfsfi",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
];
#[derive(Copy, Clone, Debug, Default, PartialEq, Eq)]
#[repr(u16)]
#[non_exhaustive]
pub enum Opcode {
    /// An illegal or unknown opcode
    #[default]
    Illegal = u16::MAX,
    /// tdwi: Trap Double Word Immediate
    Tdwi = 0,
    /// twi: Trap Word Immediate
    Twi = 1,
    /// dcbz_l: Data Cache Block Set to Zero Locked
    DcbzL = 2,
    /// mfvscr: Move from Vector Status and Control Register
    Mfvscr = 3,
    /// mtvscr: Move to Vector Status and Control Register
    Mtvscr = 4,
    /// vaddcuw: Vector Add Carryout Unsigned Word
    Vaddcuw = 5,
    /// vaddfp: Vector Add Floating Point
    Vaddfp = 6,
    /// vaddsbs: Vector Add Signed Byte Saturate
    Vaddsbs = 7,
    /// vaddshs: Vector Add Signed Half Word Saturate
    Vaddshs = 8,
    /// vaddsws: Vector Add Signed Word Saturate
    Vaddsws = 9,
    /// vaddubm: Vector Add Unsigned Byte Modulo
    Vaddubm = 10,
    /// vaddubs: Vector Add Unsigned Byte Saturate
    Vaddubs = 11,
    /// vadduhm: Vector Add Unsigned Half Word Modulo
    Vadduhm = 12,
    /// vadduhs: Vector Add Unsigned Half Word Saturate
    Vadduhs = 13,
    /// vadduwm: Vector Add Unsigned Word Modulo
    Vadduwm = 14,
    /// vadduws: Vector Add Unsigned Word Saturate
    Vadduws = 15,
    /// vand: Vector Logical AND
    Vand = 16,
    /// vandc: Vector Logical AND with Complement
    Vandc = 17,
    /// vavgsb: Vector Average Signed Byte
    Vavgsb = 18,
    /// vavgsh: Vector Average Signed Half Word
    Vavgsh = 19,
    /// vavgsw: Vector Average Signed Word
    Vavgsw = 20,
    /// vavgub: Vector Average Unsigned Byte
    Vavgub = 21,
    /// vavguh: Vector Average Unsigned Half Word
    Vavguh = 22,
    /// vavguw: Vector Average Unsigned Word
    Vavguw = 23,
    /// vcfsx: Vector Convert from Signed Fixed-Point Word
    Vcfsx = 24,
    /// vcfux: Vector Convert from Unsigned Fixed-Point Word
    Vcfux = 25,
    /// vcmpbfp: Vector Compare Bounds Floating Point
    Vcmpbfp = 26,
    /// vcmpeqfp: Vector Compare Equal-to-Floating Point
    Vcmpeqfp = 27,
    /// vcmpequb: Vector Compare Equal-to Unsigned Byte
    Vcmpequb = 28,
    /// vcmpequh: Vector Compare Equal-to Unsigned Half Word
    Vcmpequh = 29,
    /// vcmpequw: Vector Compare Equal-to Unsigned Word
    Vcmpequw = 30,
    /// vcmpgefp: Vector Compare Greater-Than-or-Equal-to Floating Point
    Vcmpgefp = 31,
    /// vcmpgtfp: Vector Compare Greater-Than Floating Point
    Vcmpgtfp = 32,
    /// vcmpgtsb: Vector Compare Greater-Than Signed Byte
    Vcmpgtsb = 33,
    /// vcmpgtsh: Vector Compare Greater-Than Condition Register Signed Half Word
    Vcmpgtsh = 34,
    /// vcmpgtsw: Vector Compare Greater-Than Signed Word
    Vcmpgtsw = 35,
    /// vcmpgtub: Vector Compare Greater-Than Unsigned Byte
    Vcmpgtub = 36,
    /// vcmpgtuh: Vector Compare Greater-Than Unsigned Half Word
    Vcmpgtuh = 37,
    /// vcmpgtuw: Vector Compare Greater-Than Unsigned Word
    Vcmpgtuw = 38,
    /// vctsxs: Vector Convert to Signed Fixed-Point Word Saturate
    Vctsxs = 39,
    /// vctuxs: Vector Convert to Unsigned Fixed-Point Word Saturate
    Vctuxs = 40,
    /// vexptefp: Vector 2 Raised to the Exponent Estimate Floating Point
    Vexptefp = 41,
    /// vlogefp: Vector Log2 Estimate Floating Point
    Vlogefp = 42,
    /// vmaddfp: Vector Multiply Add Floating Point
    Vmaddfp = 43,
    /// vmaxfp: Vector Maximum Floating Point
    Vmaxfp = 44,
    /// vmaxsb: Vector Maximum Signed Byte
    Vmaxsb = 45,
    /// vmaxsh: Vector Maximum Signed Half Word
    Vmaxsh = 46,
    /// vmaxsw: Vector Maximum Signed Word
    Vmaxsw = 47,
    /// vmaxub: Vector Maximum Unsigned Byte
    Vmaxub = 48,
    /// vmaxuh: Vector Maximum Unsigned Half Word
    Vmaxuh = 49,
    /// vmaxuw: Vector Maximum Unsigned Word
    Vmaxuw = 50,
    /// vmhaddshs: Vector Multiply High and Add Signed Half Word Saturate
    Vmhaddshs = 51,
    /// vmhraddshs: Vector Multiply High Round and Add Signed Half Word Saturate
    Vmhraddshs = 52,
    /// vminfp: Vector Minimum Floating Point
    Vminfp = 53,
    /// vminsb: Vector Minimum Signed Byte
    Vminsb = 54,
    /// vminsh: Vector Minimum Signed Half Word
    Vminsh = 55,
    /// vminsw: Vector Minimum Signed Word
    Vminsw = 56,
    /// vminub: Vector Minimum Unsigned Byte
    Vminub = 57,
    /// vminuh: Vector Minimum Unsigned Half Word
    Vminuh = 58,
    /// vminuw: Vector Minimum Unsigned Word
    Vminuw = 59,
    /// vmladduhm: Vector Multiply Low and Add Unsigned Half Word Modulo
    Vmladduhm = 60,
    /// vmrghb: Vector Merge High Byte
    Vmrghb = 61,
    /// vmrghh: Vector Merge High Half Word
    Vmrghh = 62,
    /// vmrghw: Vector Merge High Word
    Vmrghw = 63,
    /// vmrglb: Vector Merge Low Byte
    Vmrglb = 64,
    /// vmrglh: Vector Merge Low Half Word
    Vmrglh = 65,
    /// vmrglw: Vector Merge Low Word
    Vmrglw = 66,
    /// vmsummbm: Vector Multiply Sum Mixed-Sign Byte Modulo
    Vmsummbm = 67,
    /// vmsumshm: Vector Multiply Sum Signed Half Word Modulo
    Vmsumshm = 68,
    /// vmsumshs: Vector Multiply Sum Signed Half Word Saturate
    Vmsumshs = 69,
    /// vmsumubm: Vector Multiply Sum Unsigned Byte Modulo
    Vmsumubm = 70,
    /// vmsumuhm: Vector Multiply Sum Unsigned Half Word Modulo
    Vmsumuhm = 71,
    /// vmsumuhs: Vector Multiply Sum Unsigned Half Word Saturate
    Vmsumuhs = 72,
    /// vmulesb: Vector Multiply Even Signed Byte
    Vmulesb = 73,
    /// vmulesh: Vector Multiply Even Signed Half Word
    Vmulesh = 74,
    /// vmuleub: Vector Multiply Even Unsigned Byte
    Vmuleub = 75,
    /// vmuleuh: Vector Multiply Even Unsigned Half Word
    Vmuleuh = 76,
    /// vmulosb: Vector Multiply Odd Signed Byte
    Vmulosb = 77,
    /// vmulosh: Vector Multiply Odd Signed Half Word
    Vmulosh = 78,
    /// vmuloub: Vector Multiply Odd Unsigned Byte
    Vmuloub = 79,
    /// vmulouh: Vector Multiply Odd Unsigned Half Word
    Vmulouh = 80,
    /// vnmsubfp: Vector Negative Multiply-Subtract Floating Point
    Vnmsubfp = 81,
    /// vnor: Vector Logical NOR
    Vnor = 82,
    /// vor: Vector Logical OR
    Vor = 83,
    /// vperm: Vector Permute
    Vperm = 84,
    /// vpkpx: Vector Pack Pixel32
    Vpkpx = 85,
    /// vpkshss: Vector Pack Signed Half Word Signed Saturate
    Vpkshss = 86,
    /// vpkshus: Vector Pack Signed Half Word Unsigned Saturate
    Vpkshus = 87,
    /// vpkswss: Vector Pack Signed Word Signed Saturate
    Vpkswss = 88,
    /// vpkswus: Vector Pack Signed Word Unsigned Saturate
    Vpkswus = 89,
    /// vpkuhum: Vector Pack Unsigned Half Word Unsigned Modulo
    Vpkuhum = 90,
    /// vpkuhus: Vector Pack Unsigned Half Word Unsigned Saturate
    Vpkuhus = 91,
    /// vpkuwum: Vector Pack Unsigned Word Unsigned Modulo
    Vpkuwum = 92,
    /// vpkuwus: Vector Pack Unsigned Word Unsigned Saturate
    Vpkuwus = 93,
    /// vrefp: Vector Reciprocal Estimate Floating Point
    Vrefp = 94,
    /// vrfim: Vector Round to Floating-Point Integer toward Minus Infinity
    Vrfim = 95,
    /// vrfin: Vector Round to Floating-Point Integer Nearest
    Vrfin = 96,
    /// vrfip: Vector Round to Floating-Point Integer toward Plus Infinity
    Vrfip = 97,
    /// vrfiz: Vector Round to Floating-Point Integer toward Zero
    Vrfiz = 98,
    /// vrlb: Vector Rotate Left Integer Byte
    Vrlb = 99,
    /// vrlh: Vector Rotate Left Integer Half Word
    Vrlh = 100,
    /// vrlw: Vector Rotate Left Integer Word
    Vrlw = 101,
    /// vrsqrtefp: Vector Reciprocal Square Root Estimate Floating Point
    Vrsqrtefp = 102,
    /// vsel: Vector Conditional Select
    Vsel = 103,
    /// vsl: Vector Shift Left
    Vsl = 104,
    /// vslb: Vector Shift Left Integer Byte
    Vslb = 105,
    /// vsldoi: Vector Shift Left Double by Octet Immediate
    Vsldoi = 106,
    /// vslh: Vector Shift Left Integer Half Word
    Vslh = 107,
    /// vslo: Vector Shift Left by Octet
    Vslo = 108,
    /// vslw: Vector Shift Left Integer Word
    Vslw = 109,
    /// vspltb: Vector Splat Byte
    Vspltb = 110,
    /// vsplth: Vector Splat Half Word
    Vsplth = 111,
    /// vspltisb: Vector Splat Immediate Signed Byte
    Vspltisb = 112,
    /// vspltish: Vector Splat Immediate Signed Half Word
    Vspltish = 113,
    /// vspltisw: Vector Splat Immediate Signed Word
    Vspltisw = 114,
    /// vspltw: Vector Splat Word
    Vspltw = 115,
    /// vsr: Vector Shift Right
    Vsr = 116,
    /// vsrab: Vector Shift Right Algebraic Byte
    Vsrab = 117,
    /// vsrah: Vector Shift Right Algebraic Half Word
    Vsrah = 118,
    /// vsraw: Vector Shift Right Algebraic Word
    Vsraw = 119,
    /// vsrb: Vector Shift Right Byte
    Vsrb = 120,
    /// vsrh: Vector Shift Right Half Word
    Vsrh = 121,
    /// vsro: Vector Shift Right by Octet
    Vsro = 122,
    /// vsrw: Vector Shift Right Word
    Vsrw = 123,
    /// vsubcuw: Vector Subtract Carryout Unsigned Word
    Vsubcuw = 124,
    /// vsubfp: Vector Subtract Floating Point
    Vsubfp = 125,
    /// vsubsbs: Vector Subtract Signed Byte Saturate
    Vsubsbs = 126,
    /// vsubshs: Vector Subtract Signed Half Word Saturate
    Vsubshs = 127,
    /// vsubsws: Vector Subtract Signed Word Saturate
    Vsubsws = 128,
    /// vsububm: Vector Subtract Unsigned Byte Modulo
    Vsububm = 129,
    /// vsububs: Vector Subtract Unsigned Byte Saturate
    Vsububs = 130,
    /// vsubuhm: Vector Subtract Unsigned Half Word Modulo
    Vsubuhm = 131,
    /// vsubuhs: Vector Subtract Unsigned Half Word Saturate
    Vsubuhs = 132,
    /// vsubuwm: Vector Subtract Unsigned Word Modulo
    Vsubuwm = 133,
    /// vsubuws: Vector Subtract Unsigned Word Saturate
    Vsubuws = 134,
    /// vsumsws: Vector Sum Across Signed Word Saturate
    Vsumsws = 135,
    /// vsum2sws: Vector Sum Across Partial (1/2) Signed Word Saturate
    Vsum2sws = 136,
    /// vsum4sbs: Vector Sum Across Partial (1/4) Signed Byte Saturate
    Vsum4sbs = 137,
    /// vsum4shs: Vector Sum Across Partial (1/4) Signed Half Word Saturate
    Vsum4shs = 138,
    /// vsum4ubs: Vector Sum Across Partial (1/4) Unsigned Byte Saturate
    Vsum4ubs = 139,
    /// vupkhpx: Vector Unpack High Pixel16
    Vupkhpx = 140,
    /// vupkhsb: Vector Unpack High Signed Byte
    Vupkhsb = 141,
    /// vupkhsh: Vector Unpack High Signed Half Word
    Vupkhsh = 142,
    /// vupklpx: Vector Unpack Low Pixel16
    Vupklpx = 143,
    /// vupklsb: Vector Unpack Low Signed Byte
    Vupklsb = 144,
    /// vupklsh: Vector Unpack Low Signed Half Word
    Vupklsh = 145,
    /// vxor: Vector Logical XOR
    Vxor = 146,
    /// mulli: Multiply Low Immediate
    Mulli = 147,
    /// subfic: Subtract from Immediate Carrying
    Subfic = 148,
    /// cmpli: Compare Logical Immediate
    Cmpli = 149,
    /// cmpi: Compare Immediate
    Cmpi = 150,
    /// addic: Add Immediate Carrying
    Addic = 151,
    /// addic.: Add Immediate Carrying and Record
    Addic_ = 152,
    /// addi: Add Immediate
    Addi = 153,
    /// addis: Add Immediate Shifted
    Addis = 154,
    /// bc: Branch Conditional
    Bc = 155,
    /// sc: System Call
    Sc = 156,
    /// b: Branch
    B = 157,
    /// bcctr: Branch Conditional to Count Register
    Bcctr = 158,
    /// bclr: Branch Conditional to Link Register
    Bclr = 159,
    /// crand: Condition Register AND
    Crand = 160,
    /// crandc: Condition Register AND with Complement
    Crandc = 161,
    /// creqv: Condition Register Equivalent
    Creqv = 162,
    /// crnand: Condition Register NAND
    Crnand = 163,
    /// crnor: Condition Register NOR
    Crnor = 164,
    /// cror: Condition Register OR
    Cror = 165,
    /// crorc: Condition Register OR with Complement
    Crorc = 166,
    /// crxor: Condition Register XOR
    Crxor = 167,
    /// isync: Instruction Synchronize
    Isync = 168,
    /// mcrf: Move Condition Register Field
    Mcrf = 169,
    /// rfi: Return from Interrupt
    Rfi = 170,
    /// rfid: Return from Interrupt Double Word
    Rfid = 171,
    /// rlwimi: Rotate Left Word Immediate then Mask Insert
    Rlwimi = 172,
    /// rlwinm: Rotate Left Word Immediate then AND with Mask
    Rlwinm = 173,
    /// rlwnm: Rotate Left Word then AND with Mask
    Rlwnm = 174,
    /// ori: OR Immediate
    Ori = 175,
    /// oris: OR Immediate Shifted
    Oris = 176,
    /// xori: XOR Immediate
    Xori = 177,
    /// xoris: XOR Immediate Shifted
    Xoris = 178,
    /// andi.: AND Immediate
    Andi_ = 179,
    /// andis.: AND Immediate Shifted
    Andis_ = 180,
    /// rldcl: Rotate Left Double Word then Clear Left
    Rldcl = 181,
    /// rldcr: Rotate Left Double Word then Clear Right
    Rldcr = 182,
    /// rldic: Rotate Left Double Word Immediate then Clear
    Rldic = 183,
    /// rldicl: Rotate Left Double Word Immediate then Clear Left
    Rldicl = 184,
    /// rldicr: Rotate Left Double Word Immediate then Clear Right
    Rldicr = 185,
    /// rldimi: Rotate Left Double Word Immediate then Mask Insert
    Rldimi = 186,
    /// add: Add
    Add = 187,
    /// addc: Add Carrying
    Addc = 188,
    /// adde: Add Extended
    Adde = 189,
    /// addme: Add to Minus One Extended
    Addme = 190,
    /// addze: Add to Zero Extended
    Addze = 191,
    /// and: AND
    And = 192,
    /// andc: AND with Complement
    Andc = 193,
    /// cmp: Compare
    Cmp = 194,
    /// cmpl: Compare Logical
    Cmpl = 195,
    /// cntlzd: Count Leading Zeros Double Word
    Cntlzd = 196,
    /// cntlzw: Count Leading Zeros Word
    Cntlzw = 197,
    /// dcbf: Data Cache Block Flush
    Dcbf = 198,
    /// dcbi: Data Cache Block Invalidate
    Dcbi = 199,
    /// dcbst: Data Cache Block Store
    Dcbst = 200,
    /// dcbt: Data Cache Block Touch
    Dcbt = 201,
    /// dcbtst: Data Cache Block Touch for Store
    Dcbtst = 202,
    /// dcbz: Data Cache Block Clear to Zero
    Dcbz = 203,
    /// divd: Divide Double Word
    Divd = 204,
    /// divdu: Divide Double Word Unsigned
    Divdu = 205,
    /// divw: Divide Word
    Divw = 206,
    /// divwu: Divide Word Unsigned
    Divwu = 207,
    /// eciwx: External Control In Word Indexed
    Eciwx = 208,
    /// ecowx: External Control Out Word Indexed
    Ecowx = 209,
    /// eieio: Enforce In-Order Execution of I/O
    Eieio = 210,
    /// eqv: Equivalent
    Eqv = 211,
    /// extsb: Extend Sign Byte
    Extsb = 212,
    /// extsh: Extend Sign Half Word
    Extsh = 213,
    /// extsw: Extend Sign Word
    Extsw = 214,
    /// icbi: Instruction Cache Block Invalidate
    Icbi = 215,
    /// lbzux: Load Byte and Zero with Update Indexed
    Lbzux = 216,
    /// lbzx: Load Byte and Zero Indexed
    Lbzx = 217,
    /// ldarx: Load Double Word and Reserve Indexed
    Ldarx = 218,
    /// ldux: Load Double Word with Update Indexed
    Ldux = 219,
    /// ldx: Load Double Word Indexed
    Ldx = 220,
    /// lfdux: Load Floating-Point Double with Update Indexed
    Lfdux = 221,
    /// lfdx: Load Floating-Point Double Indexed
    Lfdx = 222,
    /// lfsux: Load Floating-Point Single with Update Indexed
    Lfsux = 223,
    /// lfsx: Load Floating-Point Single Indexed
    Lfsx = 224,
    /// lhaux: Load Half Word Algebraic with Update Indexed
    Lhaux = 225,
    /// lhax: Load Half Word Algebraic Indexed
    Lhax = 226,
    /// lhbrx: Load Half Word Byte-Reverse Indexed
    Lhbrx = 227,
    /// lhzux: Load Half Word and Zero with Update Indexed
    Lhzux = 228,
    /// lhzx: Load Half Word and Zero Indexed
    Lhzx = 229,
    /// lswi: Load String Word Immediate
    Lswi = 230,
    /// lswx: Load String Word Indexed
    Lswx = 231,
    /// lwarx: Load String Word and Reverse Indexed
    Lwarx = 232,
    /// lwaux: Load Word Algebraic with Update Indexed
    Lwaux = 233,
    /// lwax: Load Word Algebraic Indexed
    Lwax = 234,
    /// lwbrx: Load String Word and Byte-Reverse Indexed
    Lwbrx = 235,
    /// lwzux: Load Word and Zero with Update Indexed
    Lwzux = 236,
    /// lwzx: Load Word and Zero Indexed
    Lwzx = 237,
    /// mcrxr: Move to Condition Register from XER
    Mcrxr = 238,
    /// mfcr: Move from Condition Register
    Mfcr = 239,
    /// mfmsr: Move from Machine State Register
    Mfmsr = 240,
    /// mfspr: Move from Special-Purpose Register
    Mfspr = 241,
    /// mfsr: Move from Segment Register
    Mfsr = 242,
    /// mfsrin: Move from Segment Register Indirect
    Mfsrin = 243,
    /// mftb: Move from Time Base
    Mftb = 244,
    /// mtcrf: Move to Condition Register Fields
    Mtcrf = 245,
    /// mtmsr: Move to Machine State Register
    Mtmsr = 246,
    /// mtmsrd: Move to Machine State Register Double Word
    Mtmsrd = 247,
    /// mtspr: Move to Special-Purpose Register
    Mtspr = 248,
    /// mtsr: Move to Segment Register
    Mtsr = 249,
    /// mtsrd: Move to Segment Register Double Word
    Mtsrd = 250,
    /// mtsrdin: Move to Segment Register Double Word Indirect
    Mtsrdin = 251,
    /// mtsrin: Move to Segment Register Indirect
    Mtsrin = 252,
    /// mulhd: Multiply High Double Word
    Mulhd = 253,
    /// mulhdu: Multiply High Double Word Unsigned
    Mulhdu = 254,
    /// mulhw: Multiply High Word
    Mulhw = 255,
    /// mulhwu: Multiply High Word Unsigned
    Mulhwu = 256,
    /// mulld: Multiply Low Double Word
    Mulld = 257,
    /// mullw: Multiply Low Word
    Mullw = 258,
    /// nand: NAND
    Nand = 259,
    /// neg: Negate
    Neg = 260,
    /// nor: NOR
    Nor = 261,
    /// or: OR
    Or = 262,
    /// orc: OR with Complement
    Orc = 263,
    /// slbia: SLB Invalidate All
    Slbia = 264,
    /// slbie: SLB Invalidate Entry
    Slbie = 265,
    /// sld: Shift Left Double Word
    Sld = 266,
    /// slw: Shift Left Word
    Slw = 267,
    /// srad: Shift Right Algebraic Double Word
    Srad = 268,
    /// sradi: Shift Right Algebraic Double Word Immediate
    Sradi = 269,
    /// sraw: Shift Right Algebraic Word
    Sraw = 270,
    /// srawi: Shift Right Algebraic Word Immediate
    Srawi = 271,
    /// srd: Shift Right Double Word
    Srd = 272,
    /// srw: Shift Right Word
    Srw = 273,
    /// stbux: Store Byte with Update Indexed
    Stbux = 274,
    /// stbx: Store Byte Indexed
    Stbx = 275,
    /// stdcx: Store Double Word Conditional Indexed
    Stdcx = 276,
    /// stdux: Store Double Word with Update Indexed
    Stdux = 277,
    /// stdx: Store Double Word Indexed
    Stdx = 278,
    /// stfdux: Store Floating-Point Double with Update Indexed
    Stfdux = 279,
    /// stfdx: Store Floating-Point Double Indexed
    Stfdx = 280,
    /// stfiwx: Store Floating-Point as Integer Word Indexed
    Stfiwx = 281,
    /// stfsux: Store Floating-Point Single with Update Indexed
    Stfsux = 282,
    /// stfsx: Store Floating-Point Single Indexed
    Stfsx = 283,
    /// sthbrx: Store Half Word Byte-Reverse Indexed
    Sthbrx = 284,
    /// sthux: Store Half Word with Update Indexed
    Sthux = 285,
    /// sthx: Store Half Word Indexed
    Sthx = 286,
    /// stswi: Store String Word Immediate
    Stswi = 287,
    /// stswx: Store String Word Indexed
    Stswx = 288,
    /// stwbrx: Store Word Byte-Reverse Indexed
    Stwbrx = 289,
    /// stwcx.: Store Word Conditional Indexed
    Stwcx_ = 290,
    /// stwux: Store Word Indexed
    Stwux = 291,
    /// stwx: Store Word Indexed
    Stwx = 292,
    /// subf: Subtract From Carrying
    Subf = 293,
    /// subfc: Subtract from Carrying
    Subfc = 294,
    /// subfe: Subtract from Extended
    Subfe = 295,
    /// subfme: Subtract from Minus One Extended
    Subfme = 296,
    /// subfze: Subtract from Zero Extended
    Subfze = 297,
    /// sync: Synchronize
    Sync = 298,
    /// td: Trap Double Word
    Td = 299,
    /// tlbie: Translation Lookaside Buffer Invalidate Entry
    Tlbie = 300,
    /// tlbsync: TLB Synchronize
    Tlbsync = 301,
    /// tw: Trap Word
    Tw = 302,
    /// xor: XOR
    Xor = 303,
    /// dss: Data Stream Stop
    Dss = 304,
    /// dst: Data Stream Touch
    Dst = 305,
    /// dstst: Data Stream Touch for Store
    Dstst = 306,
    /// lvebx: Load Vector Element Byte Indexed
    Lvebx = 307,
    /// lvehx: Load Vector Element Half Word Indexed
    Lvehx = 308,
    /// lvewx: Load Vector Element Word Indexed
    Lvewx = 309,
    /// lvsl: Load Vector for Shift Left
    Lvsl = 310,
    /// lvsr: Load Vector for Shift Right
    Lvsr = 311,
    /// lvx: Load Vector Indexed
    Lvx = 312,
    /// lvxl: Load Vector Indexed LRU
    Lvxl = 313,
    /// stvebx: Store Vector Element Byte Indexed
    Stvebx = 314,
    /// stvehx: Store Vector Element Half Word Indexed
    Stvehx = 315,
    /// stvewx: Store Vector Element Word Indexed
    Stvewx = 316,
    /// stvx: Store Vector Indexed
    Stvx = 317,
    /// stvxl: Store Vector Indexed LRU
    Stvxl = 318,
    /// lwz: Load Word and Zero
    Lwz = 319,
    /// lwzu: Load Word and Zero with Update
    Lwzu = 320,
    /// lbz: Load Byte and Zero
    Lbz = 321,
    /// lbzu: Load Byte and Zero with Update
    Lbzu = 322,
    /// stw: Store Word
    Stw = 323,
    /// stwu: Store Word with Update
    Stwu = 324,
    /// stb: Store Byte
    Stb = 325,
    /// stbu: Store Byte with Update
    Stbu = 326,
    /// lhz: Load Half Word and Zero
    Lhz = 327,
    /// lhzu: Load Half Word and Zero with Update
    Lhzu = 328,
    /// lha: Load Half Word Algebraic
    Lha = 329,
    /// lhau: Load Half Word Algebraic with Update
    Lhau = 330,
    /// sth: Store Half Word
    Sth = 331,
    /// sthu: Store Half Word with Update
    Sthu = 332,
    /// lmw: Load Multiple Word
    Lmw = 333,
    /// stmw: Store Multiple Word
    Stmw = 334,
    /// lfs: Load Floating-Point Single
    Lfs = 335,
    /// lfsu: Load Floating-Point Single with Update
    Lfsu = 336,
    /// lfd: Load Floating-Point Double
    Lfd = 337,
    /// lfdu: Load Floating-Point Double with Update
    Lfdu = 338,
    /// stfs: Store Floating-Point Single
    Stfs = 339,
    /// stfsu: Store Floating-Point Single with Update
    Stfsu = 340,
    /// stfd: Store Floating-Point Double
    Stfd = 341,
    /// stfdu: Store Floating-Point Double with Update
    Stfdu = 342,
    /// ld: Load Double Word
    Ld = 343,
    /// ldu: Load Double Word with Update
    Ldu = 344,
    /// lwa: Load Word Algebraic
    Lwa = 345,
    /// fadds: Floating Add (Single-Precision)
    Fadds = 346,
    /// fdivs: Floating Divide (Single-Precision)
    Fdivs = 347,
    /// fmadds: Floating Multiply-Add (Single-Precision)
    Fmadds = 348,
    /// fmsubs: Floating Multiply-Subtract (Single-Precision)
    Fmsubs = 349,
    /// fmuls: Floating Multiply (Single-Precision)
    Fmuls = 350,
    /// fnmadds: Floating Negative Multiply-Add (Single-Precision)
    Fnmadds = 351,
    /// fnmsubs: Floating Negative Multiply-Subtract (Single-Precision)
    Fnmsubs = 352,
    /// fres: Floating Reciprocal Estimate Single
    Fres = 353,
    /// fsubs: Floating Subtract (Single-Precision)
    Fsubs = 354,
    /// std: Store Double Word
    Std = 355,
    /// stdu: Store Double Word with Update
    Stdu = 356,
    /// fabs: Floating Absolute Value
    Fabs = 357,
    /// fadd: Floating Add (Double-Precision)
    Fadd = 358,
    /// fcfid: Floating Convert from Integer Double Word
    Fcfid = 359,
    /// fcmpo: Floating Compare Ordered
    Fcmpo = 360,
    /// fcmpu: Floating Compare Unordered
    Fcmpu = 361,
    /// fctid: Floating Convert to Integer Double Word
    Fctid = 362,
    /// fctidz: Floating Convert to Integer Double Word with Round toward Zero
    Fctidz = 363,
    /// fctiw: Floating Convert to Integer Word
    Fctiw = 364,
    /// fctiwz: Floating Convert to Integer Word with Round toward Zero
    Fctiwz = 365,
    /// fdiv: Floating Divide (Double-Precision)
    Fdiv = 366,
    /// fmadd: Floating Multiply-Add (Double-Precision)
    Fmadd = 367,
    /// fmr: Floating Move Register (Double-Precision)
    Fmr = 368,
    /// fmsub: Floating Multiply-Subtract (Double-Precision)
    Fmsub = 369,
    /// fmul: Floating Multiply (Double-Precision)
    Fmul = 370,
    /// fnabs: Floating Negative Absolute Value
    Fnabs = 371,
    /// fneg: Floating Negate
    Fneg = 372,
    /// fnmadd: Floating Negative Multiply-Add (Double-Precision)
    Fnmadd = 373,
    /// fnmsub: Floating Negative Multiply-Subtract (Double-Precision)
    Fnmsub = 374,
    /// frsp: Floating Round to Single
    Frsp = 375,
    /// frsqrte: Floating Reciprocal Square Root Estimate
    Frsqrte = 376,
    /// fsel: Floating Select
    Fsel = 377,
    /// fsub: Floating Subtract (Double-Precision)
    Fsub = 378,
    /// mcrfs: Move to Condition Register from FPSCR
    Mcrfs = 379,
    /// mffs: Move from FPSCR
    Mffs = 380,
    /// mtfsb0: Move to FPSCR Bit 0
    Mtfsb0 = 381,
    /// mtfsb1: Move to FPSCR Bit 1
    Mtfsb1 = 382,
    /// mtfsf: Move to FPSCR Fields
    Mtfsf = 383,
    /// mtfsfi: Move to FPSCR Field Immediate
    Mtfsfi = 384,
}
impl Opcode {
    #[inline]
    pub fn _mnemonic(self) -> &'static str {
        OPCODE_NAMES[self as usize]
    }
    #[inline]
    pub fn _detect(code: u32) -> Self {
        let entry = OPCODE_ENTRIES[(code >> 26) as usize];
        for i in entry.0..entry.1 {
            let pattern = OPCODE_PATTERNS[i as usize];
            if (code & pattern.0) == pattern.1 {
                // Safety: The enum is repr(u16) and the value is within the enum's range
                return unsafe { core::mem::transmute::<u16, Opcode>(i) };
            }
        }
        Self::Illegal
    }
}
impl From<u16> for Opcode {
    #[inline]
    fn from(value: u16) -> Self {
        if value > 384 {
            Self::Illegal
        } else {
            // Safety: The enum is repr(u16) and the value is within the enum's range
            unsafe { core::mem::transmute::<u16, Self>(value) }
        }
    }
}
impl From<Opcode> for u16 {
    #[inline]
    fn from(value: Opcode) -> Self {
        value as u16
    }
}
impl Ins {
    /// simm: Signed Immediate
    #[inline(always)]
    pub const fn field_simm(&self) -> i16 {
        (self.code & 0xffff) as i16
    }
    /// uimm: Unsigned Immediate
    #[inline(always)]
    pub const fn field_uimm(&self) -> u16 {
        (self.code & 0xffff) as u16
    }
    /// vsimm: Vector Signed Immediate
    #[inline(always)]
    pub const fn field_vsimm(&self) -> i8 {
        ((((self.code >> 16) & 0x1f) << 3) as i8) >> 3
    }
    /// vuimm: Vector Unsigned Immediate
    #[inline(always)]
    pub const fn field_vuimm(&self) -> u8 {
        ((self.code >> 16) & 0x1f) as u8
    }
    /// offset: Branch Offset
    #[inline(always)]
    pub const fn field_offset(&self) -> i16 {
        (self.code & 0xffff) as i16
    }
    /// BO: Branch Options
    #[inline(always)]
    pub const fn field_bo(&self) -> u8 {
        ((self.code >> 21) & 0x1f) as u8
    }
    /// BI: Branch Condition Register Bit
    #[inline(always)]
    pub const fn field_bi(&self) -> u8 {
        ((self.code >> 16) & 0x1f) as u8
    }
    /// BD: Branch Destination (14-bit)
    #[inline(always)]
    pub const fn field_bd(&self) -> i16 {
        (self.code & 0xfffc) as i16
    }
    /// LI: Branch Destination (24-bit)
    #[inline(always)]
    pub const fn field_li(&self) -> i32 {
        (((self.code & 0x3fffffc) << 6) as i32) >> 6
    }
    /// SH: Shift Amount
    #[inline(always)]
    pub const fn field_sh(&self) -> u8 {
        ((self.code >> 11) & 0x1f) as u8
    }
    /// MB: Mask Begin
    #[inline(always)]
    pub const fn field_mb(&self) -> u8 {
        ((self.code >> 6) & 0x1f) as u8
    }
    /// ME: Mask End
    #[inline(always)]
    pub const fn field_me(&self) -> u8 {
        ((self.code >> 1) & 0x1f) as u8
    }
    /// rS: Source Register
    #[inline(always)]
    pub const fn field_rs(&self) -> u8 {
        ((self.code >> 21) & 0x1f) as u8
    }
    /// rD: Destination Register
    #[inline(always)]
    pub const fn field_rd(&self) -> u8 {
        ((self.code >> 21) & 0x1f) as u8
    }
    /// rA: Register A
    #[inline(always)]
    pub const fn field_ra(&self) -> u8 {
        ((self.code >> 16) & 0x1f) as u8
    }
    /// rB: Register B
    #[inline(always)]
    pub const fn field_rb(&self) -> u8 {
        ((self.code >> 11) & 0x1f) as u8
    }
    /// sr: Segment Register
    #[inline(always)]
    pub const fn field_sr(&self) -> u8 {
        ((self.code >> 16) & 0xf) as u8
    }
    /// spr: Special Purpose Register
    #[inline(always)]
    pub const fn field_spr(&self) -> u16 {
        let value = ((self.code >> 11) & 0x3ff) as u16;
        ((value & 0b11111_00000) >> 5) | ((value & 0b00000_11111) << 5)
    }
    /// frS: Source Floating-Point Register
    #[inline(always)]
    pub const fn field_frs(&self) -> u8 {
        ((self.code >> 21) & 0x1f) as u8
    }
    /// frD: Destination Floating-Point Register
    #[inline(always)]
    pub const fn field_frd(&self) -> u8 {
        ((self.code >> 21) & 0x1f) as u8
    }
    /// frA: Floating-Point Register A
    #[inline(always)]
    pub const fn field_fra(&self) -> u8 {
        ((self.code >> 16) & 0x1f) as u8
    }
    /// frB: Floating-Point Register B
    #[inline(always)]
    pub const fn field_frb(&self) -> u8 {
        ((self.code >> 11) & 0x1f) as u8
    }
    /// frC: Floating-Point Register C
    #[inline(always)]
    pub const fn field_frc(&self) -> u8 {
        ((self.code >> 6) & 0x1f) as u8
    }
    /// vS: Vector Source Register
    #[inline(always)]
    pub const fn field_vs(&self) -> u8 {
        ((self.code >> 21) & 0x1f) as u8
    }
    /// vD: Vector Destination Register
    #[inline(always)]
    pub const fn field_vd(&self) -> u8 {
        ((self.code >> 21) & 0x1f) as u8
    }
    /// vA: Vector Register A
    #[inline(always)]
    pub const fn field_va(&self) -> u8 {
        ((self.code >> 16) & 0x1f) as u8
    }
    /// vB: Vector Register B
    #[inline(always)]
    pub const fn field_vb(&self) -> u8 {
        ((self.code >> 11) & 0x1f) as u8
    }
    /// vC: Vector Register C
    #[inline(always)]
    pub const fn field_vc(&self) -> u8 {
        ((self.code >> 6) & 0x1f) as u8
    }
    /// crbD: Condition Register Bit Destination
    #[inline(always)]
    pub const fn field_crbd(&self) -> u8 {
        ((self.code >> 21) & 0x1f) as u8
    }
    /// crbA: Condition Register Bit A
    #[inline(always)]
    pub const fn field_crba(&self) -> u8 {
        ((self.code >> 16) & 0x1f) as u8
    }
    /// crbB: Condition Register Bit B
    #[inline(always)]
    pub const fn field_crbb(&self) -> u8 {
        ((self.code >> 11) & 0x1f) as u8
    }
    /// crfD: Condition Register Field Destination
    #[inline(always)]
    pub const fn field_crfd(&self) -> u8 {
        ((self.code >> 23) & 0x7) as u8
    }
    /// crfS: Condition Register Field Source
    #[inline(always)]
    pub const fn field_crfs(&self) -> u8 {
        ((self.code >> 18) & 0x7) as u8
    }
    /// crm: Condition Register Mask
    #[inline(always)]
    pub const fn field_crm(&self) -> u8 {
        ((self.code >> 12) & 0xff) as u8
    }
    /// NB
    #[inline(always)]
    pub const fn field_nb(&self) -> u8 {
        ((self.code >> 11) & 0x1f) as u8
    }
    /// tbr: Time Base
    #[inline(always)]
    pub const fn field_tbr(&self) -> u16 {
        let value = ((self.code >> 11) & 0x3ff) as u16;
        ((value & 0b11111_00000) >> 5) | ((value & 0b00000_11111) << 5)
    }
    /// mtfsf_FM: Field Mask for mtfsf
    #[inline(always)]
    pub const fn field_mtfsf_fm(&self) -> u8 {
        ((self.code >> 17) & 0xff) as u8
    }
    /// mtfsf_IMM: Immediate for mtfsfi
    #[inline(always)]
    pub const fn field_mtfsf_imm(&self) -> u8 {
        ((self.code >> 12) & 0xf) as u8
    }
    /// spr_SPRG: SPRG index for m[tf]sprg
    #[inline(always)]
    pub const fn field_spr_sprg(&self) -> u8 {
        ((self.code >> 16) & 0x3) as u8
    }
    /// spr_BAT: IBAT/DBAT index for m[tf][id]bat[ul]
    #[inline(always)]
    pub const fn field_spr_bat(&self) -> u8 {
        ((self.code >> 17) & 0x3) as u8
    }
    /// TO: Bitset for tw and twi
    #[inline(always)]
    pub const fn field_to(&self) -> u8 {
        ((self.code >> 21) & 0x1f) as u8
    }
    /// L: Bitset for cmp, cmpi, cmpl, cmpli
    #[inline(always)]
    pub const fn field_l(&self) -> u8 {
        ((self.code >> 21) & 0x1) as u8
    }
    /// STRM: Stream ID
    #[inline(always)]
    pub const fn field_strm(&self) -> u8 {
        ((self.code >> 21) & 0x3) as u8
    }
    /// SHB
    #[inline(always)]
    pub const fn field_shb(&self) -> u8 {
        ((self.code >> 6) & 0xf) as u8
    }
    /// OE: Field used by XO-form instructions to enable setting OV and SO in the XER.
    #[inline(always)]
    pub const fn field_oe(&self) -> bool {
        (self.code & 0x400) == 0x400
    }
    /// Rc: Record Bit
    #[inline(always)]
    pub const fn field_rc(&self) -> bool {
        (self.code & 0x1) == 0x1
    }
    /// LK: Link Bit
    #[inline(always)]
    pub const fn field_lk(&self) -> bool {
        (self.code & 0x1) == 0x1
    }
    /// AA: Absolute Address Bit
    #[inline(always)]
    pub const fn field_aa(&self) -> bool {
        (self.code & 0x2) == 0x2
    }
    /// BP: Predict branch to be taken
    #[inline(always)]
    pub const fn field_bp(&self) -> bool {
        (self.code & 0x200000) == 0x200000 && self.field_bd() >= 0x0
    }
    /// BNP: Predict branch not to be taken (fall through)
    #[inline(always)]
    pub const fn field_bnp(&self) -> bool {
        (self.code & 0x200000) == 0x200000 && self.field_bd() < 0x0
    }
    /// BP_ND: Predict branch to be taken (implicit dest for LR/CTR)
    #[inline(always)]
    pub const fn field_bp_nd(&self) -> bool {
        (self.code & 0x200000) == 0x200000
    }
    /// A: All bit
    #[inline(always)]
    pub const fn field_a(&self) -> bool {
        (self.code & 0x2000000) == 0x2000000
    }
    /// T: Transient bit
    #[inline(always)]
    pub const fn field_t(&self) -> bool {
        (self.code & 0x2000000) == 0x2000000
    }
}
pub type Arguments = [Argument; 5];
pub const EMPTY_ARGS: Arguments = [
    Argument::None,
    Argument::None,
    Argument::None,
    Argument::None,
    Argument::None,
];
type MnemonicFunction = fn(&mut ParsedIns, Ins);
fn basic_tdwi(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "tdwi",
        args: [
            Argument::OpaqueU(OpaqueU(ins.field_to() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::Simm(Simm(ins.field_simm() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_twi(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "twi",
        args: [
            Argument::OpaqueU(OpaqueU(ins.field_to() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::Simm(Simm(ins.field_simm() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn simplified_twi(out: &mut ParsedIns, ins: Ins) {
    if ins.field_to() == 0x8 {
        *out = ParsedIns {
            mnemonic: "twgti",
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::Simm(Simm(ins.field_simm() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_to() == 0x6 {
        *out = ParsedIns {
            mnemonic: "twllei",
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::Simm(Simm(ins.field_simm() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_to() == 0x1f {
        *out = ParsedIns {
            mnemonic: "twui",
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::Simm(Simm(ins.field_simm() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    basic_twi(out, ins)
}
fn basic_dcbz_l(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "dcbz_l",
        args: [
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_mfvscr(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "mfvscr",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_mtvscr(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "mtvscr",
        args: [
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vaddcuw(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vaddcuw",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vaddfp(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vaddfp",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vaddsbs(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vaddsbs",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vaddshs(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vaddshs",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vaddsws(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vaddsws",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vaddubm(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vaddubm",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vaddubs(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vaddubs",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vadduhm(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vadduhm",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vadduhs(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vadduhs",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vadduwm(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vadduwm",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vadduws(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vadduws",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vand(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vand",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vandc(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vandc",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vavgsb(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vavgsb",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vavgsh(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vavgsh",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vavgsw(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vavgsw",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vavgub(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vavgub",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vavguh(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vavguh",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vavguw(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vavguw",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vcfsx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vcfsx",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::Uimm(Uimm(ins.field_vuimm() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vcfux(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vcfux",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::Uimm(Uimm(ins.field_vuimm() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vcmpbfp(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["vcmpbfp", "vcmpbfp."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_vd() as _)),
                Argument::GPR(GPR(ins.field_va() as _)),
                Argument::GPR(GPR(ins.field_vb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_vcmpeqfp(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["vcmpeqfp", "vcmpeqfp."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_vd() as _)),
                Argument::GPR(GPR(ins.field_va() as _)),
                Argument::GPR(GPR(ins.field_vb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_vcmpequb(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["vcmpequb", "vcmpequb."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_vd() as _)),
                Argument::GPR(GPR(ins.field_va() as _)),
                Argument::GPR(GPR(ins.field_vb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_vcmpequh(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["vcmpequh", "vcmpequh."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_vd() as _)),
                Argument::GPR(GPR(ins.field_va() as _)),
                Argument::GPR(GPR(ins.field_vb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_vcmpequw(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["vcmpequw", "vcmpequw."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_vd() as _)),
                Argument::GPR(GPR(ins.field_va() as _)),
                Argument::GPR(GPR(ins.field_vb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_vcmpgefp(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["vcmpgefp", "vcmpgefp."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_vd() as _)),
                Argument::GPR(GPR(ins.field_va() as _)),
                Argument::GPR(GPR(ins.field_vb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_vcmpgtfp(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["vcmpgtfp", "vcmpgtfp."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_vd() as _)),
                Argument::GPR(GPR(ins.field_va() as _)),
                Argument::GPR(GPR(ins.field_vb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_vcmpgtsb(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["vcmpgtsb", "vcmpgtsb."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_vd() as _)),
                Argument::GPR(GPR(ins.field_va() as _)),
                Argument::GPR(GPR(ins.field_vb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_vcmpgtsh(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["vcmpgtsh", "vcmpgtsh."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_vd() as _)),
                Argument::GPR(GPR(ins.field_va() as _)),
                Argument::GPR(GPR(ins.field_vb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_vcmpgtsw(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["vcmpgtsw", "vcmpgtsw."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_vd() as _)),
                Argument::GPR(GPR(ins.field_va() as _)),
                Argument::GPR(GPR(ins.field_vb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_vcmpgtub(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["vcmpgtub", "vcmpgtub."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_vd() as _)),
                Argument::GPR(GPR(ins.field_va() as _)),
                Argument::GPR(GPR(ins.field_vb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_vcmpgtuh(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["vcmpgtuh", "vcmpgtuh."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_vd() as _)),
                Argument::GPR(GPR(ins.field_va() as _)),
                Argument::GPR(GPR(ins.field_vb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_vcmpgtuw(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["vcmpgtuw", "vcmpgtuw."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_vd() as _)),
                Argument::GPR(GPR(ins.field_va() as _)),
                Argument::GPR(GPR(ins.field_vb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_vctsxs(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vctsxs",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::Uimm(Uimm(ins.field_vuimm() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vctuxs(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vctuxs",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::Uimm(Uimm(ins.field_vuimm() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vexptefp(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vexptefp",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vlogefp(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vlogefp",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vmaddfp(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmaddfp",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vc() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
        ],
    };
}
fn basic_vmaxfp(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmaxfp",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vmaxsb(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmaxsb",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vmaxsh(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmaxsh",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vmaxsw(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmaxsw",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vmaxub(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmaxub",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vmaxuh(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmaxuh",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vmaxuw(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmaxuw",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vmhaddshs(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmhaddshs",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::GPR(GPR(ins.field_vc() as _)),
            Argument::None,
        ],
    };
}
fn basic_vmhraddshs(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmhraddshs",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::GPR(GPR(ins.field_vc() as _)),
            Argument::None,
        ],
    };
}
fn basic_vminfp(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vminfp",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vminsb(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vminsb",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vminsh(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vminsh",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vminsw(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vminsw",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vminub(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vminub",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vminuh(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vminuh",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vminuw(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vminuw",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vmladduhm(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmladduhm",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::GPR(GPR(ins.field_vc() as _)),
            Argument::None,
        ],
    };
}
fn basic_vmrghb(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmrghb",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vmrghh(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmrghh",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vmrghw(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmrghw",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vmrglb(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmrglb",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vmrglh(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmrglh",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vmrglw(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmrglw",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vmsummbm(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmsummbm",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::GPR(GPR(ins.field_vc() as _)),
            Argument::None,
        ],
    };
}
fn basic_vmsumshm(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmsumshm",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::GPR(GPR(ins.field_vc() as _)),
            Argument::None,
        ],
    };
}
fn basic_vmsumshs(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmsumshs",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::GPR(GPR(ins.field_vc() as _)),
            Argument::None,
        ],
    };
}
fn basic_vmsumubm(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmsumubm",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::GPR(GPR(ins.field_vc() as _)),
            Argument::None,
        ],
    };
}
fn basic_vmsumuhm(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmsumuhm",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::GPR(GPR(ins.field_vc() as _)),
            Argument::None,
        ],
    };
}
fn basic_vmsumuhs(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmsumuhs",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::GPR(GPR(ins.field_vc() as _)),
            Argument::None,
        ],
    };
}
fn basic_vmulesb(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmulesb",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vmulesh(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmulesh",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vmuleub(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmuleub",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vmuleuh(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmuleuh",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vmulosb(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmulosb",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vmulosh(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmulosh",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vmuloub(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmuloub",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vmulouh(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmulouh",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vnmsubfp(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vnmsubfp",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vc() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
        ],
    };
}
fn basic_vnor(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vnor",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vor(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vor",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vperm(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vperm",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::GPR(GPR(ins.field_vc() as _)),
            Argument::None,
        ],
    };
}
fn basic_vpkpx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vpkpx",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vpkshss(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vpkshss",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vpkshus(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vpkshus",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vpkswss(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vpkswss",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vpkswus(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vpkswus",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vpkuhum(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vpkuhum",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vpkuhus(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vpkuhus",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vpkuwum(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vpkuwum",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vpkuwus(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vpkuwus",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vrefp(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vrefp",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vrfim(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vrfim",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vrfin(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vrfin",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vrfip(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vrfip",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vrfiz(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vrfiz",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vrlb(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vrlb",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vrlh(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vrlh",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vrlw(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vrlw",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vrsqrtefp(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vrsqrtefp",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vsel(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vsel",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::GPR(GPR(ins.field_vc() as _)),
            Argument::None,
        ],
    };
}
fn basic_vsl(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vsl",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vslb(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vslb",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vsldoi(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vsldoi",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::OpaqueU(OpaqueU(ins.field_shb() as _)),
            Argument::None,
        ],
    };
}
fn basic_vslh(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vslh",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vslo(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vslo",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vslw(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vslw",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vspltb(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vspltb",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::Uimm(Uimm(ins.field_vuimm() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vsplth(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vsplth",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::Uimm(Uimm(ins.field_vuimm() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vspltisb(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vspltisb",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::Simm(Simm(ins.field_vsimm() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vspltish(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vspltish",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::Simm(Simm(ins.field_vsimm() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vspltisw(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vspltisw",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::Simm(Simm(ins.field_vsimm() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vspltw(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vspltw",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::Uimm(Uimm(ins.field_vuimm() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vsr(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vsr",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vsrab(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vsrab",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vsrah(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vsrah",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vsraw(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vsraw",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vsrb(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vsrb",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vsrh(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vsrh",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vsro(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vsro",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vsrw(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vsrw",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vsubcuw(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vsubcuw",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vsubfp(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vsubfp",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vsubsbs(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vsubsbs",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vsubshs(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vsubshs",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vsubsws(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vsubsws",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vsububm(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vsububm",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vsububs(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vsububs",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vsubuhm(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vsubuhm",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vsubuhs(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vsubuhs",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vsubuwm(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vsubuwm",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vsubuws(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vsubuws",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vsumsws(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vsumsws",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vsum2sws(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vsum2sws",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vsum4sbs(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vsum4sbs",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vsum4shs(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vsum4shs",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vsum4ubs(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vsum4ubs",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vupkhpx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vupkhpx",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vupkhsb(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vupkhsb",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vupkhsh(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vupkhsh",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vupklpx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vupklpx",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vupklsb(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vupklsb",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vupklsh(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vupklsh",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vxor(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vxor",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_va() as _)),
            Argument::GPR(GPR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_mulli(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "mulli",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::Simm(Simm(ins.field_simm() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_subfic(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "subfic",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::Simm(Simm(ins.field_simm() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_cmpli(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "cmpli",
        args: [
            Argument::CRField(CRField(ins.field_crfd() as _)),
            Argument::OpaqueU(OpaqueU(ins.field_l() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::Uimm(Uimm(ins.field_uimm() as _)),
            Argument::None,
        ],
    };
}
fn simplified_cmpli(out: &mut ParsedIns, ins: Ins) {
    if ins.field_crfd() == 0x0 && ins.field_l() == 0x0 {
        *out = ParsedIns {
            mnemonic: "cmplwi",
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::Uimm(Uimm(ins.field_uimm() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_l() == 0x0 {
        *out = ParsedIns {
            mnemonic: "cmplwi",
            args: [
                Argument::CRField(CRField(ins.field_crfd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::Uimm(Uimm(ins.field_uimm() as _)),
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_crfd() == 0x0 && ins.field_l() == 0x1 {
        *out = ParsedIns {
            mnemonic: "cmpldi",
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::Uimm(Uimm(ins.field_uimm() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_l() == 0x1 {
        *out = ParsedIns {
            mnemonic: "cmpldi",
            args: [
                Argument::CRField(CRField(ins.field_crfd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::Uimm(Uimm(ins.field_uimm() as _)),
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    basic_cmpli(out, ins)
}
fn basic_cmpi(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "cmpi",
        args: [
            Argument::CRField(CRField(ins.field_crfd() as _)),
            Argument::OpaqueU(OpaqueU(ins.field_l() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::Simm(Simm(ins.field_simm() as _)),
            Argument::None,
        ],
    };
}
fn simplified_cmpi(out: &mut ParsedIns, ins: Ins) {
    if ins.field_crfd() == 0x0 && ins.field_l() == 0x0 {
        *out = ParsedIns {
            mnemonic: "cmpwi",
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::Simm(Simm(ins.field_simm() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_l() == 0x0 {
        *out = ParsedIns {
            mnemonic: "cmpwi",
            args: [
                Argument::CRField(CRField(ins.field_crfd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::Simm(Simm(ins.field_simm() as _)),
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_crfd() == 0x0 && ins.field_l() == 0x1 {
        *out = ParsedIns {
            mnemonic: "cmpdi",
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::Simm(Simm(ins.field_simm() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_l() == 0x1 {
        *out = ParsedIns {
            mnemonic: "cmpdi",
            args: [
                Argument::CRField(CRField(ins.field_crfd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::Simm(Simm(ins.field_simm() as _)),
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    basic_cmpi(out, ins)
}
fn basic_addic(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "addic",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::Simm(Simm(ins.field_simm() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn simplified_addic(out: &mut ParsedIns, ins: Ins) {
    if ins.field_simm() < 0x0 && ins.field_simm() != -0x8000 {
        *out = ParsedIns {
            mnemonic: "subic",
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::Simm(Simm((-ins.field_simm()) as _)),
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    basic_addic(out, ins)
}
fn basic_addic_(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "addic.",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::Simm(Simm(ins.field_simm() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn simplified_addic_(out: &mut ParsedIns, ins: Ins) {
    if ins.field_simm() < 0x0 && ins.field_simm() != -0x8000 {
        *out = ParsedIns {
            mnemonic: "subic.",
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::Simm(Simm((-ins.field_simm()) as _)),
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    basic_addic_(out, ins)
}
fn basic_addi(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "addi",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::Simm(Simm(ins.field_simm() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn simplified_addi(out: &mut ParsedIns, ins: Ins) {
    if ins.field_ra() == 0x0 {
        *out = ParsedIns {
            mnemonic: "li",
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::Simm(Simm(ins.field_simm() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_simm() < 0x0 && ins.field_simm() != -0x8000 {
        *out = ParsedIns {
            mnemonic: "subi",
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::Simm(Simm((-ins.field_simm()) as _)),
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    basic_addi(out, ins)
}
fn basic_addis(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "addis",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::Uimm(Uimm(ins.field_uimm() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn simplified_addis(out: &mut ParsedIns, ins: Ins) {
    if ins.field_ra() == 0x0 {
        *out = ParsedIns {
            mnemonic: "lis",
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::Uimm(Uimm(ins.field_uimm() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_simm() < 0x0 && ins.field_simm() != -0x8000 {
        *out = ParsedIns {
            mnemonic: "subis",
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::Simm(Simm((-ins.field_simm()) as _)),
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    basic_addis(out, ins)
}
fn basic_bc(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 16] = [
            "bc",
            "bcl",
            "bca",
            "bcla",
            "bc+",
            "bcl+",
            "bca+",
            "bcla+",
            "bc-",
            "bcl-",
            "bca-",
            "bcla-",
            "<illegal>",
            "<illegal>",
            "<illegal>",
            "<illegal>",
        ];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_lk() as usize | (ins.field_aa() as usize) << 1
                | (ins.field_bp() as usize) << 2 | (ins.field_bnp() as usize) << 3],
            args: [
                Argument::OpaqueU(OpaqueU(ins.field_bo() as _)),
                Argument::CRBit(CRBit(ins.field_bi() as _)),
                Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn simplified_bc(out: &mut ParsedIns, ins: Ins) {
    if (ins.field_bo() & 0x1e) == 0xc && ins.field_bi() == 0x0 {
        *out = {
            const MODIFIERS: [&str; 16] = [
                "blt",
                "bltl",
                "blta",
                "bltla",
                "blt+",
                "bltl+",
                "blta+",
                "bltla+",
                "blt-",
                "bltl-",
                "blta-",
                "bltla-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_aa() as usize) << 1 | (ins.field_bp() as usize) << 2
                    | (ins.field_bnp() as usize) << 3],
                args: [
                    Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && (ins.field_bi() & 0x3) == 0x0 {
        *out = {
            const MODIFIERS: [&str; 16] = [
                "blt",
                "bltl",
                "blta",
                "bltla",
                "blt+",
                "bltl+",
                "blta+",
                "bltla+",
                "blt-",
                "bltl-",
                "blta-",
                "bltla-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_aa() as usize) << 1 | (ins.field_bp() as usize) << 2
                    | (ins.field_bnp() as usize) << 3],
                args: [
                    Argument::CRField(CRField(ins.field_crfs() as _)),
                    Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && ins.field_bi() == 0x1 {
        *out = {
            const MODIFIERS: [&str; 16] = [
                "ble",
                "blel",
                "blea",
                "blela",
                "ble+",
                "blel+",
                "blea+",
                "blela+",
                "ble-",
                "blel-",
                "blea-",
                "blela-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_aa() as usize) << 1 | (ins.field_bp() as usize) << 2
                    | (ins.field_bnp() as usize) << 3],
                args: [
                    Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && (ins.field_bi() & 0x3) == 0x1 {
        *out = {
            const MODIFIERS: [&str; 16] = [
                "ble",
                "blel",
                "blea",
                "blela",
                "ble+",
                "blel+",
                "blea+",
                "blela+",
                "ble-",
                "blel-",
                "blea-",
                "blela-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_aa() as usize) << 1 | (ins.field_bp() as usize) << 2
                    | (ins.field_bnp() as usize) << 3],
                args: [
                    Argument::CRField(CRField(ins.field_crfs() as _)),
                    Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && ins.field_bi() == 0x2 {
        *out = {
            const MODIFIERS: [&str; 16] = [
                "beq",
                "beql",
                "beqa",
                "beqla",
                "beq+",
                "beql+",
                "beqa+",
                "beqla+",
                "beq-",
                "beql-",
                "beqa-",
                "beqla-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_aa() as usize) << 1 | (ins.field_bp() as usize) << 2
                    | (ins.field_bnp() as usize) << 3],
                args: [
                    Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && (ins.field_bi() & 0x3) == 0x2 {
        *out = {
            const MODIFIERS: [&str; 16] = [
                "beq",
                "beql",
                "beqa",
                "beqla",
                "beq+",
                "beql+",
                "beqa+",
                "beqla+",
                "beq-",
                "beql-",
                "beqa-",
                "beqla-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_aa() as usize) << 1 | (ins.field_bp() as usize) << 2
                    | (ins.field_bnp() as usize) << 3],
                args: [
                    Argument::CRField(CRField(ins.field_crfs() as _)),
                    Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && ins.field_bi() == 0x0 {
        *out = {
            const MODIFIERS: [&str; 16] = [
                "bge",
                "bgel",
                "bgea",
                "bgela",
                "bge+",
                "bgel+",
                "bgea+",
                "bgela+",
                "bge-",
                "bgel-",
                "bgea-",
                "bgela-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_aa() as usize) << 1 | (ins.field_bp() as usize) << 2
                    | (ins.field_bnp() as usize) << 3],
                args: [
                    Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && (ins.field_bi() & 0x3) == 0x0 {
        *out = {
            const MODIFIERS: [&str; 16] = [
                "bge",
                "bgel",
                "bgea",
                "bgela",
                "bge+",
                "bgel+",
                "bgea+",
                "bgela+",
                "bge-",
                "bgel-",
                "bgea-",
                "bgela-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_aa() as usize) << 1 | (ins.field_bp() as usize) << 2
                    | (ins.field_bnp() as usize) << 3],
                args: [
                    Argument::CRField(CRField(ins.field_crfs() as _)),
                    Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && ins.field_bi() == 0x1 {
        *out = {
            const MODIFIERS: [&str; 16] = [
                "bgt",
                "bgtl",
                "bgta",
                "bgtla",
                "bgt+",
                "bgtl+",
                "bgta+",
                "bgtla+",
                "bgt-",
                "bgtl-",
                "bgta-",
                "bgtla-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_aa() as usize) << 1 | (ins.field_bp() as usize) << 2
                    | (ins.field_bnp() as usize) << 3],
                args: [
                    Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && (ins.field_bi() & 0x3) == 0x1 {
        *out = {
            const MODIFIERS: [&str; 16] = [
                "bgt",
                "bgtl",
                "bgta",
                "bgtla",
                "bgt+",
                "bgtl+",
                "bgta+",
                "bgtla+",
                "bgt-",
                "bgtl-",
                "bgta-",
                "bgtla-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_aa() as usize) << 1 | (ins.field_bp() as usize) << 2
                    | (ins.field_bnp() as usize) << 3],
                args: [
                    Argument::CRField(CRField(ins.field_crfs() as _)),
                    Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && ins.field_bi() == 0x2 {
        *out = {
            const MODIFIERS: [&str; 16] = [
                "bne",
                "bnel",
                "bnea",
                "bnela",
                "bne+",
                "bnel+",
                "bnea+",
                "bnela+",
                "bne-",
                "bnel-",
                "bnea-",
                "bnela-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_aa() as usize) << 1 | (ins.field_bp() as usize) << 2
                    | (ins.field_bnp() as usize) << 3],
                args: [
                    Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && (ins.field_bi() & 0x3) == 0x2 {
        *out = {
            const MODIFIERS: [&str; 16] = [
                "bne",
                "bnel",
                "bnea",
                "bnela",
                "bne+",
                "bnel+",
                "bnea+",
                "bnela+",
                "bne-",
                "bnel-",
                "bnea-",
                "bnela-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_aa() as usize) << 1 | (ins.field_bp() as usize) << 2
                    | (ins.field_bnp() as usize) << 3],
                args: [
                    Argument::CRField(CRField(ins.field_crfs() as _)),
                    Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && ins.field_bi() == 0x3 {
        *out = {
            const MODIFIERS: [&str; 16] = [
                "bso",
                "bsol",
                "bsoa",
                "bsola",
                "bso+",
                "bsol+",
                "bsoa+",
                "bsola+",
                "bso-",
                "bsol-",
                "bsoa-",
                "bsola-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_aa() as usize) << 1 | (ins.field_bp() as usize) << 2
                    | (ins.field_bnp() as usize) << 3],
                args: [
                    Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && (ins.field_bi() & 0x3) == 0x3 {
        *out = {
            const MODIFIERS: [&str; 16] = [
                "bso",
                "bsol",
                "bsoa",
                "bsola",
                "bso+",
                "bsol+",
                "bsoa+",
                "bsola+",
                "bso-",
                "bsol-",
                "bsoa-",
                "bsola-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_aa() as usize) << 1 | (ins.field_bp() as usize) << 2
                    | (ins.field_bnp() as usize) << 3],
                args: [
                    Argument::CRField(CRField(ins.field_crfs() as _)),
                    Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && ins.field_bi() == 0x3 {
        *out = {
            const MODIFIERS: [&str; 16] = [
                "bns",
                "bnsl",
                "bnsa",
                "bnsla",
                "bns+",
                "bnsl+",
                "bnsa+",
                "bnsla+",
                "bns-",
                "bnsl-",
                "bnsa-",
                "bnsla-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_aa() as usize) << 1 | (ins.field_bp() as usize) << 2
                    | (ins.field_bnp() as usize) << 3],
                args: [
                    Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && (ins.field_bi() & 0x3) == 0x3 {
        *out = {
            const MODIFIERS: [&str; 16] = [
                "bns",
                "bnsl",
                "bnsa",
                "bnsla",
                "bns+",
                "bnsl+",
                "bnsa+",
                "bnsla+",
                "bns-",
                "bnsl-",
                "bnsa-",
                "bnsla-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_aa() as usize) << 1 | (ins.field_bp() as usize) << 2
                    | (ins.field_bnp() as usize) << 3],
                args: [
                    Argument::CRField(CRField(ins.field_crfs() as _)),
                    Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x10 && ins.field_bi() == 0x0 {
        *out = {
            const MODIFIERS: [&str; 16] = [
                "bdnz",
                "bdnzl",
                "bdnza",
                "bdnzla",
                "bdnz+",
                "bdnzl+",
                "bdnza+",
                "bdnzla+",
                "bdnz-",
                "bdnzl-",
                "bdnza-",
                "bdnzla-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_aa() as usize) << 1 | (ins.field_bp() as usize) << 2
                    | (ins.field_bnp() as usize) << 3],
                args: [
                    Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x8 {
        *out = {
            const MODIFIERS: [&str; 16] = [
                "bdnzt",
                "bdnztl",
                "bdnzta",
                "bdnztla",
                "bdnzt+",
                "bdnztl+",
                "bdnzta+",
                "bdnztla+",
                "bdnzt-",
                "bdnztl-",
                "bdnzta-",
                "bdnztla-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_aa() as usize) << 1 | (ins.field_bp() as usize) << 2
                    | (ins.field_bnp() as usize) << 3],
                args: [
                    Argument::CRBit(CRBit(ins.field_bi() as _)),
                    Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x0 {
        *out = {
            const MODIFIERS: [&str; 16] = [
                "bdnzf",
                "bdnzfl",
                "bdnzfa",
                "bdnzfla",
                "bdnzf+",
                "bdnzfl+",
                "bdnzfa+",
                "bdnzfla+",
                "bdnzf-",
                "bdnzfl-",
                "bdnzfa-",
                "bdnzfla-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_aa() as usize) << 1 | (ins.field_bp() as usize) << 2
                    | (ins.field_bnp() as usize) << 3],
                args: [
                    Argument::CRBit(CRBit(ins.field_bi() as _)),
                    Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x12 && ins.field_bi() == 0x0 {
        *out = {
            const MODIFIERS: [&str; 16] = [
                "bdz",
                "bdzl",
                "bdza",
                "bdzla",
                "bdz+",
                "bdzl+",
                "bdza+",
                "bdzla+",
                "bdz-",
                "bdzl-",
                "bdza-",
                "bdzla-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_aa() as usize) << 1 | (ins.field_bp() as usize) << 2
                    | (ins.field_bnp() as usize) << 3],
                args: [
                    Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xa {
        *out = {
            const MODIFIERS: [&str; 16] = [
                "bdzt",
                "bdztl",
                "bdzta",
                "bdztla",
                "bdzt+",
                "bdztl+",
                "bdzta+",
                "bdztla+",
                "bdzt-",
                "bdztl-",
                "bdzta-",
                "bdztla-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_aa() as usize) << 1 | (ins.field_bp() as usize) << 2
                    | (ins.field_bnp() as usize) << 3],
                args: [
                    Argument::CRBit(CRBit(ins.field_bi() as _)),
                    Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x2 {
        *out = {
            const MODIFIERS: [&str; 16] = [
                "bdzf",
                "bdzfl",
                "bdzfa",
                "bdzfla",
                "bdzf+",
                "bdzfl+",
                "bdzfa+",
                "bdzfla+",
                "bdzf-",
                "bdzfl-",
                "bdzfa-",
                "bdzfla-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_aa() as usize) << 1 | (ins.field_bp() as usize) << 2
                    | (ins.field_bnp() as usize) << 3],
                args: [
                    Argument::CRBit(CRBit(ins.field_bi() as _)),
                    Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    basic_bc(out, ins)
}
fn basic_sc(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "sc",
        args: EMPTY_ARGS,
    };
}
fn basic_b(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 4] = ["b", "bl", "ba", "bla"];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_lk() as usize
                | (ins.field_aa() as usize) << 1],
            args: [
                Argument::BranchDest(BranchDest(ins.field_li() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_bcctr(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 4] = ["bcctr", "bcctrl", "bcctr+", "bcctrl+"];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_lk() as usize
                | (ins.field_bp_nd() as usize) << 1],
            args: [
                Argument::OpaqueU(OpaqueU(ins.field_bo() as _)),
                Argument::CRBit(CRBit(ins.field_bi() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn simplified_bcctr(out: &mut ParsedIns, ins: Ins) {
    if ins.field_bo() == 0x14 && ins.field_bi() == 0x0 {
        *out = {
            const MODIFIERS: [&str; 2] = ["bctr", "bctrl"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize],
                args: EMPTY_ARGS,
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && ins.field_bi() == 0x0 {
        *out = {
            const MODIFIERS: [&str; 4] = ["bltctr", "bltctrl", "bltctr+", "bltctrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: EMPTY_ARGS,
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && (ins.field_bi() & 0x3) == 0x0 {
        *out = {
            const MODIFIERS: [&str; 4] = ["bltctr", "bltctrl", "bltctr+", "bltctrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: [
                    Argument::CRField(CRField(ins.field_crfs() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && ins.field_bi() == 0x1 {
        *out = {
            const MODIFIERS: [&str; 4] = ["blectr", "blectrl", "blectr+", "blectrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: EMPTY_ARGS,
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && (ins.field_bi() & 0x3) == 0x1 {
        *out = {
            const MODIFIERS: [&str; 4] = ["blectr", "blectrl", "blectr+", "blectrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: [
                    Argument::CRField(CRField(ins.field_crfs() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && ins.field_bi() == 0x2 {
        *out = {
            const MODIFIERS: [&str; 4] = ["beqctr", "beqctrl", "beqctr+", "beqctrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: EMPTY_ARGS,
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && (ins.field_bi() & 0x3) == 0x2 {
        *out = {
            const MODIFIERS: [&str; 4] = ["beqctr", "beqctrl", "beqctr+", "beqctrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: [
                    Argument::CRField(CRField(ins.field_crfs() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && ins.field_bi() == 0x0 {
        *out = {
            const MODIFIERS: [&str; 4] = ["bgectr", "bgectrl", "bgectr+", "bgectrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: EMPTY_ARGS,
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && (ins.field_bi() & 0x3) == 0x0 {
        *out = {
            const MODIFIERS: [&str; 4] = ["bgectr", "bgectrl", "bgectr+", "bgectrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: [
                    Argument::CRField(CRField(ins.field_crfs() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && ins.field_bi() == 0x1 {
        *out = {
            const MODIFIERS: [&str; 4] = ["bgtctr", "bgtctrl", "bgtctr+", "bgtctrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: EMPTY_ARGS,
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && (ins.field_bi() & 0x3) == 0x1 {
        *out = {
            const MODIFIERS: [&str; 4] = ["bgtctr", "bgtctrl", "bgtctr+", "bgtctrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: [
                    Argument::CRField(CRField(ins.field_crfs() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && ins.field_bi() == 0x2 {
        *out = {
            const MODIFIERS: [&str; 4] = ["bnectr", "bnectrl", "bnectr+", "bnectrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: EMPTY_ARGS,
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && (ins.field_bi() & 0x3) == 0x2 {
        *out = {
            const MODIFIERS: [&str; 4] = ["bnectr", "bnectrl", "bnectr+", "bnectrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: [
                    Argument::CRField(CRField(ins.field_crfs() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && ins.field_bi() == 0x3 {
        *out = {
            const MODIFIERS: [&str; 4] = ["bsoctr", "bsoctrl", "bsoctr+", "bsoctrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: EMPTY_ARGS,
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && (ins.field_bi() & 0x3) == 0x3 {
        *out = {
            const MODIFIERS: [&str; 4] = ["bsoctr", "bsoctrl", "bsoctr+", "bsoctrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: [
                    Argument::CRField(CRField(ins.field_crfs() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && ins.field_bi() == 0x3 {
        *out = {
            const MODIFIERS: [&str; 4] = ["bnsctr", "bnsctrl", "bnsctr+", "bnsctrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: EMPTY_ARGS,
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && (ins.field_bi() & 0x3) == 0x3 {
        *out = {
            const MODIFIERS: [&str; 4] = ["bnsctr", "bnsctrl", "bnsctr+", "bnsctrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: [
                    Argument::CRField(CRField(ins.field_crfs() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    basic_bcctr(out, ins)
}
fn basic_bclr(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 4] = ["bclr", "bclrl", "bclr+", "bclrl+"];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_lk() as usize
                | (ins.field_bp_nd() as usize) << 1],
            args: [
                Argument::OpaqueU(OpaqueU(ins.field_bo() as _)),
                Argument::CRBit(CRBit(ins.field_bi() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn simplified_bclr(out: &mut ParsedIns, ins: Ins) {
    if ins.field_bo() == 0x14 && ins.field_bi() == 0x0 {
        *out = {
            const MODIFIERS: [&str; 2] = ["blr", "blrl"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize],
                args: EMPTY_ARGS,
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && ins.field_bi() == 0x0 {
        *out = {
            const MODIFIERS: [&str; 4] = ["bltlr", "bltlrl", "bltlr+", "bltlrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: EMPTY_ARGS,
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && (ins.field_bi() & 0x3) == 0x0 {
        *out = {
            const MODIFIERS: [&str; 4] = ["bltlr", "bltlrl", "bltlr+", "bltlrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: [
                    Argument::CRField(CRField(ins.field_crfs() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && ins.field_bi() == 0x1 {
        *out = {
            const MODIFIERS: [&str; 4] = ["blelr", "blelrl", "blelr+", "blelrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: EMPTY_ARGS,
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && (ins.field_bi() & 0x3) == 0x1 {
        *out = {
            const MODIFIERS: [&str; 4] = ["blelr", "blelrl", "blelr+", "blelrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: [
                    Argument::CRField(CRField(ins.field_crfs() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && ins.field_bi() == 0x2 {
        *out = {
            const MODIFIERS: [&str; 4] = ["beqlr", "beqlrl", "beqlr+", "beqlrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: EMPTY_ARGS,
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && (ins.field_bi() & 0x3) == 0x2 {
        *out = {
            const MODIFIERS: [&str; 4] = ["beqlr", "beqlrl", "beqlr+", "beqlrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: [
                    Argument::CRField(CRField(ins.field_crfs() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && ins.field_bi() == 0x0 {
        *out = {
            const MODIFIERS: [&str; 4] = ["bgelr", "bgelrl", "bgelr+", "bgelrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: EMPTY_ARGS,
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && (ins.field_bi() & 0x3) == 0x0 {
        *out = {
            const MODIFIERS: [&str; 4] = ["bgelr", "bgelrl", "bgelr+", "bgelrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: [
                    Argument::CRField(CRField(ins.field_crfs() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && ins.field_bi() == 0x1 {
        *out = {
            const MODIFIERS: [&str; 4] = ["bgtlr", "bgtlrl", "bgtlr+", "bgtlrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: EMPTY_ARGS,
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && (ins.field_bi() & 0x3) == 0x1 {
        *out = {
            const MODIFIERS: [&str; 4] = ["bgtlr", "bgtlrl", "bgtlr+", "bgtlrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: [
                    Argument::CRField(CRField(ins.field_crfs() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && ins.field_bi() == 0x2 {
        *out = {
            const MODIFIERS: [&str; 4] = ["bnelr", "bnelrl", "bnelr+", "bnelrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: EMPTY_ARGS,
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && (ins.field_bi() & 0x3) == 0x2 {
        *out = {
            const MODIFIERS: [&str; 4] = ["bnelr", "bnelrl", "bnelr+", "bnelrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: [
                    Argument::CRField(CRField(ins.field_crfs() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && ins.field_bi() == 0x3 {
        *out = {
            const MODIFIERS: [&str; 4] = ["bsolr", "bsolrl", "bsolr+", "bsolrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: EMPTY_ARGS,
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && (ins.field_bi() & 0x3) == 0x3 {
        *out = {
            const MODIFIERS: [&str; 4] = ["bsolr", "bsolrl", "bsolr+", "bsolrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: [
                    Argument::CRField(CRField(ins.field_crfs() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && ins.field_bi() == 0x3 {
        *out = {
            const MODIFIERS: [&str; 4] = ["bnslr", "bnslrl", "bnslr+", "bnslrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: EMPTY_ARGS,
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && (ins.field_bi() & 0x3) == 0x3 {
        *out = {
            const MODIFIERS: [&str; 4] = ["bnslr", "bnslrl", "bnslr+", "bnslrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: [
                    Argument::CRField(CRField(ins.field_crfs() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x10 && ins.field_bi() == 0x0 {
        *out = {
            const MODIFIERS: [&str; 4] = ["bdnzlr", "bdnzlrl", "bdnzlr+", "bdnzlrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: EMPTY_ARGS,
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x8 {
        *out = {
            const MODIFIERS: [&str; 4] = [
                "bdnztlr",
                "bdnztlrl",
                "bdnztlr+",
                "bdnztlrl+",
            ];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: [
                    Argument::CRBit(CRBit(ins.field_bi() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x0 {
        *out = {
            const MODIFIERS: [&str; 4] = [
                "bdnzflr",
                "bdnzflrl",
                "bdnzflr+",
                "bdnzflrl+",
            ];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: [
                    Argument::CRBit(CRBit(ins.field_bi() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x12 && ins.field_bi() == 0x0 {
        *out = {
            const MODIFIERS: [&str; 4] = ["bdzlr", "bdzlrl", "bdzlr+", "bdzlrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: EMPTY_ARGS,
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xa {
        *out = {
            const MODIFIERS: [&str; 4] = ["bdztlr", "bdztlrl", "bdztlr+", "bdztlrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: [
                    Argument::CRBit(CRBit(ins.field_bi() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x0 {
        *out = {
            const MODIFIERS: [&str; 4] = ["bdzflr", "bdzflrl", "bdzflr+", "bdzflrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: [
                    Argument::CRBit(CRBit(ins.field_bi() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    basic_bclr(out, ins)
}
fn basic_crand(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "crand",
        args: [
            Argument::CRBit(CRBit(ins.field_crbd() as _)),
            Argument::CRBit(CRBit(ins.field_crba() as _)),
            Argument::CRBit(CRBit(ins.field_crbb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_crandc(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "crandc",
        args: [
            Argument::CRBit(CRBit(ins.field_crbd() as _)),
            Argument::CRBit(CRBit(ins.field_crba() as _)),
            Argument::CRBit(CRBit(ins.field_crbb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_creqv(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "creqv",
        args: [
            Argument::CRBit(CRBit(ins.field_crbd() as _)),
            Argument::CRBit(CRBit(ins.field_crba() as _)),
            Argument::CRBit(CRBit(ins.field_crbb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn simplified_creqv(out: &mut ParsedIns, ins: Ins) {
    if ins.field_crba() == ins.field_crbd() && ins.field_crbb() == ins.field_crbd() {
        *out = ParsedIns {
            mnemonic: "crset",
            args: [
                Argument::CRBit(CRBit(ins.field_crbd() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    basic_creqv(out, ins)
}
fn basic_crnand(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "crnand",
        args: [
            Argument::CRBit(CRBit(ins.field_crbd() as _)),
            Argument::CRBit(CRBit(ins.field_crba() as _)),
            Argument::CRBit(CRBit(ins.field_crbb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_crnor(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "crnor",
        args: [
            Argument::CRBit(CRBit(ins.field_crbd() as _)),
            Argument::CRBit(CRBit(ins.field_crba() as _)),
            Argument::CRBit(CRBit(ins.field_crbb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn simplified_crnor(out: &mut ParsedIns, ins: Ins) {
    if ins.field_crbb() == ins.field_crba() {
        *out = ParsedIns {
            mnemonic: "crnot",
            args: [
                Argument::CRBit(CRBit(ins.field_crbd() as _)),
                Argument::CRBit(CRBit(ins.field_crba() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    basic_crnor(out, ins)
}
fn basic_cror(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "cror",
        args: [
            Argument::CRBit(CRBit(ins.field_crbd() as _)),
            Argument::CRBit(CRBit(ins.field_crba() as _)),
            Argument::CRBit(CRBit(ins.field_crbb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn simplified_cror(out: &mut ParsedIns, ins: Ins) {
    if ins.field_crbb() == ins.field_crba() {
        *out = ParsedIns {
            mnemonic: "crmove",
            args: [
                Argument::CRBit(CRBit(ins.field_crbd() as _)),
                Argument::CRBit(CRBit(ins.field_crba() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    basic_cror(out, ins)
}
fn basic_crorc(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "crorc",
        args: [
            Argument::CRBit(CRBit(ins.field_crbd() as _)),
            Argument::CRBit(CRBit(ins.field_crba() as _)),
            Argument::CRBit(CRBit(ins.field_crbb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_crxor(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "crxor",
        args: [
            Argument::CRBit(CRBit(ins.field_crbd() as _)),
            Argument::CRBit(CRBit(ins.field_crba() as _)),
            Argument::CRBit(CRBit(ins.field_crbb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn simplified_crxor(out: &mut ParsedIns, ins: Ins) {
    if ins.field_crba() == ins.field_crbd() && ins.field_crbb() == ins.field_crbd() {
        *out = ParsedIns {
            mnemonic: "crclr",
            args: [
                Argument::CRBit(CRBit(ins.field_crbd() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    basic_crxor(out, ins)
}
fn basic_isync(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "isync",
        args: EMPTY_ARGS,
    };
}
fn basic_mcrf(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "mcrf",
        args: [
            Argument::CRField(CRField(ins.field_crfd() as _)),
            Argument::CRField(CRField(ins.field_crfs() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_rfi(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "rfi",
        args: EMPTY_ARGS,
    };
}
fn basic_rfid(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "rfid",
        args: EMPTY_ARGS,
    };
}
fn basic_rlwimi(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["rlwimi", "rlwimi."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::OpaqueU(OpaqueU(ins.field_sh() as _)),
                Argument::OpaqueU(OpaqueU(ins.field_mb() as _)),
                Argument::OpaqueU(OpaqueU(ins.field_me() as _)),
            ],
        }
    };
}
fn basic_rlwinm(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["rlwinm", "rlwinm."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::OpaqueU(OpaqueU(ins.field_sh() as _)),
                Argument::OpaqueU(OpaqueU(ins.field_mb() as _)),
                Argument::OpaqueU(OpaqueU(ins.field_me() as _)),
            ],
        }
    };
}
fn simplified_rlwinm(out: &mut ParsedIns, ins: Ins) {
    if ins.field_sh() == 0x0 && ins.field_mb() == 0x0 {
        *out = {
            const MODIFIERS: [&str; 2] = ["clrrwi", "clrrwi."];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_rc() as usize],
                args: [
                    Argument::GPR(GPR(ins.field_ra() as _)),
                    Argument::GPR(GPR(ins.field_rs() as _)),
                    Argument::OpaqueU(OpaqueU((31 - ins.field_me()) as _)),
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if ins.field_sh() == 0x0 && ins.field_me() == 0x1f {
        *out = {
            const MODIFIERS: [&str; 2] = ["clrlwi", "clrlwi."];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_rc() as usize],
                args: [
                    Argument::GPR(GPR(ins.field_ra() as _)),
                    Argument::GPR(GPR(ins.field_rs() as _)),
                    Argument::OpaqueU(OpaqueU(ins.field_mb() as _)),
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if ins.field_mb() == 0x0 && ins.field_me() == 0x1f && ins.field_sh() <= 0x10 {
        *out = {
            const MODIFIERS: [&str; 2] = ["rotlwi", "rotlwi."];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_rc() as usize],
                args: [
                    Argument::GPR(GPR(ins.field_ra() as _)),
                    Argument::GPR(GPR(ins.field_rs() as _)),
                    Argument::OpaqueU(OpaqueU(ins.field_sh() as _)),
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if ins.field_mb() == 0x0 && ins.field_me() == 0x1f && ins.field_sh() > 0x10 {
        *out = {
            const MODIFIERS: [&str; 2] = ["rotrwi", "rotrwi."];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_rc() as usize],
                args: [
                    Argument::GPR(GPR(ins.field_ra() as _)),
                    Argument::GPR(GPR(ins.field_rs() as _)),
                    Argument::OpaqueU(OpaqueU((32 - ins.field_sh()) as _)),
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if ins.field_mb() == 0x0 && ins.field_me() == 31 - ins.field_sh() {
        *out = {
            const MODIFIERS: [&str; 2] = ["slwi", "slwi."];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_rc() as usize],
                args: [
                    Argument::GPR(GPR(ins.field_ra() as _)),
                    Argument::GPR(GPR(ins.field_rs() as _)),
                    Argument::OpaqueU(OpaqueU(ins.field_sh() as _)),
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if ins.field_me() == 0x1f && ins.field_sh() == 32 - ins.field_mb() {
        *out = {
            const MODIFIERS: [&str; 2] = ["srwi", "srwi."];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_rc() as usize],
                args: [
                    Argument::GPR(GPR(ins.field_ra() as _)),
                    Argument::GPR(GPR(ins.field_rs() as _)),
                    Argument::OpaqueU(OpaqueU(ins.field_mb() as _)),
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if ins.field_sh() < 0x20 && ins.field_me() == 31 - ins.field_sh() {
        *out = {
            const MODIFIERS: [&str; 2] = ["clrlslwi", "clrlslwi."];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_rc() as usize],
                args: [
                    Argument::GPR(GPR(ins.field_ra() as _)),
                    Argument::GPR(GPR(ins.field_rs() as _)),
                    Argument::OpaqueU(OpaqueU((ins.field_mb() + ins.field_sh()) as _)),
                    Argument::OpaqueU(OpaqueU(ins.field_sh() as _)),
                    Argument::None,
                ],
            }
        };
        return;
    }
    if ins.field_mb() == 0x0 {
        *out = {
            const MODIFIERS: [&str; 2] = ["extlwi", "extlwi."];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_rc() as usize],
                args: [
                    Argument::GPR(GPR(ins.field_ra() as _)),
                    Argument::GPR(GPR(ins.field_rs() as _)),
                    Argument::OpaqueU(OpaqueU((ins.field_me() + 1) as _)),
                    Argument::OpaqueU(OpaqueU(ins.field_sh() as _)),
                    Argument::None,
                ],
            }
        };
        return;
    }
    if ins.field_me() == 0x1f && ins.field_sh() >= 32 - ins.field_mb() {
        *out = {
            const MODIFIERS: [&str; 2] = ["extrwi", "extrwi."];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_rc() as usize],
                args: [
                    Argument::GPR(GPR(ins.field_ra() as _)),
                    Argument::GPR(GPR(ins.field_rs() as _)),
                    Argument::OpaqueU(OpaqueU((32 - ins.field_mb()) as _)),
                    Argument::OpaqueU(
                        OpaqueU((ins.field_sh() - (32 - ins.field_mb())) as _),
                    ),
                    Argument::None,
                ],
            }
        };
        return;
    }
    basic_rlwinm(out, ins)
}
fn basic_rlwnm(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["rlwnm", "rlwnm."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::OpaqueU(OpaqueU(ins.field_mb() as _)),
                Argument::OpaqueU(OpaqueU(ins.field_me() as _)),
            ],
        }
    };
}
fn simplified_rlwnm(out: &mut ParsedIns, ins: Ins) {
    if ins.field_mb() == 0x0 && ins.field_me() == 0x1f {
        *out = {
            const MODIFIERS: [&str; 2] = ["rotlw", "rotlw."];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_rc() as usize],
                args: [
                    Argument::GPR(GPR(ins.field_ra() as _)),
                    Argument::GPR(GPR(ins.field_rs() as _)),
                    Argument::GPR(GPR(ins.field_rb() as _)),
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    basic_rlwnm(out, ins)
}
fn basic_ori(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "ori",
        args: [
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::Uimm(Uimm(ins.field_uimm() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn simplified_ori(out: &mut ParsedIns, ins: Ins) {
    if ins.field_ra() == 0x0 && ins.field_rs() == 0x0 && ins.field_uimm() == 0x0 {
        *out = ParsedIns {
            mnemonic: "nop",
            args: EMPTY_ARGS,
        };
        return;
    }
    basic_ori(out, ins)
}
fn basic_oris(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "oris",
        args: [
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::Uimm(Uimm(ins.field_uimm() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_xori(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "xori",
        args: [
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::Uimm(Uimm(ins.field_uimm() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_xoris(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "xoris",
        args: [
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::Uimm(Uimm(ins.field_uimm() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_andi_(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "andi.",
        args: [
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::Uimm(Uimm(ins.field_uimm() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_andis_(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "andis.",
        args: [
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::Uimm(Uimm(ins.field_uimm() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_rldcl(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["rldcl", "rldcl."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::OpaqueU(OpaqueU(ins.field_mb() as _)),
                Argument::None,
            ],
        }
    };
}
fn basic_rldcr(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["rldcr", "rldcr."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::OpaqueU(OpaqueU(ins.field_me() as _)),
                Argument::None,
            ],
        }
    };
}
fn basic_rldic(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["rldic", "rldic."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::OpaqueU(OpaqueU(ins.field_sh() as _)),
                Argument::OpaqueU(OpaqueU(ins.field_mb() as _)),
                Argument::None,
            ],
        }
    };
}
fn basic_rldicl(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["rldicl", "rldicl."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::OpaqueU(OpaqueU(ins.field_sh() as _)),
                Argument::OpaqueU(OpaqueU(ins.field_mb() as _)),
                Argument::None,
            ],
        }
    };
}
fn basic_rldicr(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["rldicr", "rldicr."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::OpaqueU(OpaqueU(ins.field_sh() as _)),
                Argument::OpaqueU(OpaqueU(ins.field_me() as _)),
                Argument::None,
            ],
        }
    };
}
fn basic_rldimi(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["rldimi", "rldimi."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::OpaqueU(OpaqueU(ins.field_sh() as _)),
                Argument::OpaqueU(OpaqueU(ins.field_mb() as _)),
                Argument::None,
            ],
        }
    };
}
fn basic_add(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 4] = ["add", "addo", "add.", "addo."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_oe() as usize
                | (ins.field_rc() as usize) << 1],
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_addc(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 4] = ["addc", "addco", "addc.", "addco."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_oe() as usize
                | (ins.field_rc() as usize) << 1],
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_adde(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 4] = ["adde", "addeo", "adde.", "addeo."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_oe() as usize
                | (ins.field_rc() as usize) << 1],
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_addme(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 4] = ["addme", "addmeo", "addme.", "addmeo."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_oe() as usize
                | (ins.field_rc() as usize) << 1],
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_addze(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 4] = ["addze", "addzeo", "addze.", "addzeo."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_oe() as usize
                | (ins.field_rc() as usize) << 1],
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_and(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["and", "and."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_andc(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["andc", "andc."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_cmp(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "cmp",
        args: [
            Argument::CRField(CRField(ins.field_crfd() as _)),
            Argument::OpaqueU(OpaqueU(ins.field_l() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
        ],
    };
}
fn simplified_cmp(out: &mut ParsedIns, ins: Ins) {
    if ins.field_crfd() == 0x0 && ins.field_l() == 0x0 {
        *out = ParsedIns {
            mnemonic: "cmpw",
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_l() == 0x0 {
        *out = ParsedIns {
            mnemonic: "cmpw",
            args: [
                Argument::CRField(CRField(ins.field_crfd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_crfd() == 0x0 && ins.field_l() == 0x1 {
        *out = ParsedIns {
            mnemonic: "cmpd",
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_l() == 0x1 {
        *out = ParsedIns {
            mnemonic: "cmpd",
            args: [
                Argument::CRField(CRField(ins.field_crfd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    basic_cmp(out, ins)
}
fn basic_cmpl(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "cmpl",
        args: [
            Argument::CRField(CRField(ins.field_crfd() as _)),
            Argument::OpaqueU(OpaqueU(ins.field_l() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
        ],
    };
}
fn simplified_cmpl(out: &mut ParsedIns, ins: Ins) {
    if ins.field_crfd() == 0x0 && ins.field_l() == 0x0 {
        *out = ParsedIns {
            mnemonic: "cmplw",
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_l() == 0x0 {
        *out = ParsedIns {
            mnemonic: "cmplw",
            args: [
                Argument::CRField(CRField(ins.field_crfd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_crfd() == 0x0 && ins.field_l() == 0x1 {
        *out = ParsedIns {
            mnemonic: "cmpld",
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_l() == 0x1 {
        *out = ParsedIns {
            mnemonic: "cmpld",
            args: [
                Argument::CRField(CRField(ins.field_crfd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    basic_cmpl(out, ins)
}
fn basic_cntlzd(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["cntlzd", "cntlzd."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_cntlzw(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["cntlzw", "cntlzw."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_dcbf(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "dcbf",
        args: [
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_dcbi(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "dcbi",
        args: [
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_dcbst(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "dcbst",
        args: [
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_dcbt(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "dcbt",
        args: [
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_dcbtst(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "dcbtst",
        args: [
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_dcbz(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "dcbz",
        args: [
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_divd(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 4] = ["divd", "divdo", "divd.", "divdo."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_oe() as usize
                | (ins.field_rc() as usize) << 1],
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_divdu(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 4] = ["divdu", "divduo", "divdu.", "divduo."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_oe() as usize
                | (ins.field_rc() as usize) << 1],
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_divw(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 4] = ["divw", "divwo", "divw.", "divwo."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_oe() as usize
                | (ins.field_rc() as usize) << 1],
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_divwu(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 4] = ["divwu", "divwuo", "divwu.", "divwuo."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_oe() as usize
                | (ins.field_rc() as usize) << 1],
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_eciwx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "eciwx",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_ecowx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "ecowx",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_eieio(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "eieio",
        args: EMPTY_ARGS,
    };
}
fn basic_eqv(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["eqv", "eqv."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_extsb(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["extsb", "extsb."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_extsh(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["extsh", "extsh."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_extsw(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["extsw", "extsw."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_icbi(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["icbi", "icbi."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_lbzux(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lbzux",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lbzx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lbzx",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_ldarx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "ldarx",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_ldux(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "ldux",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_ldx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "ldx",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lfdux(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lfdux",
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lfdx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lfdx",
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lfsux(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lfsux",
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lfsx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lfsx",
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lhaux(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lhaux",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lhax(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lhax",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lhbrx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lhbrx",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lhzux(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lhzux",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lhzx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lhzx",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lswi(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lswi",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::OpaqueU(OpaqueU(ins.field_nb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lswx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lswx",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lwarx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lwarx",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lwaux(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lwaux",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lwax(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lwax",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lwbrx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lwbrx",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lwzux(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lwzux",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lwzx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lwzx",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_mcrxr(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "mcrxr",
        args: [
            Argument::CRField(CRField(ins.field_crfd() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_mfcr(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "mfcr",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_mfmsr(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "mfmsr",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_mfspr(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "mfspr",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::SPR(SPR(ins.field_spr() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn simplified_mfspr(out: &mut ParsedIns, ins: Ins) {
    if ins.field_spr() == 0x1 {
        *out = ParsedIns {
            mnemonic: "mfxer",
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_spr() == 0x8 {
        *out = ParsedIns {
            mnemonic: "mflr",
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_spr() == 0x9 {
        *out = ParsedIns {
            mnemonic: "mfctr",
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_spr() == 0x12 {
        *out = ParsedIns {
            mnemonic: "mfdsisr",
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_spr() == 0x13 {
        *out = ParsedIns {
            mnemonic: "mfdar",
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_spr() == 0x16 {
        *out = ParsedIns {
            mnemonic: "mfdec",
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_spr() == 0x19 {
        *out = ParsedIns {
            mnemonic: "mfsdr1",
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_spr() == 0x1a {
        *out = ParsedIns {
            mnemonic: "mfsrr0",
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_spr() == 0x1b {
        *out = ParsedIns {
            mnemonic: "mfsrr1",
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_spr() & 0x3fc) == 0x110 {
        *out = ParsedIns {
            mnemonic: "mfsprg",
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::OpaqueU(OpaqueU(ins.field_spr_sprg() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_spr() == 0x11a {
        *out = ParsedIns {
            mnemonic: "mfear",
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_spr() & 0x3f9) == 0x210 {
        *out = ParsedIns {
            mnemonic: "mfibatu",
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::OpaqueU(OpaqueU(ins.field_spr_bat() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_spr() & 0x3f9) == 0x211 {
        *out = ParsedIns {
            mnemonic: "mfibatl",
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::OpaqueU(OpaqueU(ins.field_spr_bat() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_spr() & 0x3f9) == 0x218 {
        *out = ParsedIns {
            mnemonic: "mfdbatu",
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::OpaqueU(OpaqueU(ins.field_spr_bat() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_spr() & 0x3f9) == 0x219 {
        *out = ParsedIns {
            mnemonic: "mfdbatl",
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::OpaqueU(OpaqueU(ins.field_spr_bat() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    basic_mfspr(out, ins)
}
fn basic_mfsr(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "mfsr",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::SR(SR(ins.field_sr() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_mfsrin(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "mfsrin",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_mftb(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "mftb",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::OpaqueU(OpaqueU(ins.field_tbr() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_mtcrf(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "mtcrf",
        args: [
            Argument::OpaqueU(OpaqueU(ins.field_crm() as _)),
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_mtmsr(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "mtmsr",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_mtmsrd(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "mtmsrd",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_mtspr(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "mtspr",
        args: [
            Argument::SPR(SPR(ins.field_spr() as _)),
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn simplified_mtspr(out: &mut ParsedIns, ins: Ins) {
    if ins.field_spr() == 0x1 {
        *out = ParsedIns {
            mnemonic: "mtxer",
            args: [
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_spr() == 0x8 {
        *out = ParsedIns {
            mnemonic: "mtlr",
            args: [
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_spr() == 0x9 {
        *out = ParsedIns {
            mnemonic: "mtctr",
            args: [
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_spr() == 0x12 {
        *out = ParsedIns {
            mnemonic: "mtdsisr",
            args: [
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_spr() == 0x13 {
        *out = ParsedIns {
            mnemonic: "mtdar",
            args: [
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_spr() == 0x16 {
        *out = ParsedIns {
            mnemonic: "mtdec",
            args: [
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_spr() == 0x19 {
        *out = ParsedIns {
            mnemonic: "mtsdr1",
            args: [
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_spr() == 0x1a {
        *out = ParsedIns {
            mnemonic: "mtsrr0",
            args: [
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_spr() == 0x1b {
        *out = ParsedIns {
            mnemonic: "mtsrr1",
            args: [
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_spr() & 0x3fc) == 0x110 {
        *out = ParsedIns {
            mnemonic: "mtsprg",
            args: [
                Argument::OpaqueU(OpaqueU(ins.field_spr_sprg() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_spr() == 0x11a {
        *out = ParsedIns {
            mnemonic: "mtear",
            args: [
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_spr() == 0x11c {
        *out = ParsedIns {
            mnemonic: "mttbl",
            args: [
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_spr() == 0x11d {
        *out = ParsedIns {
            mnemonic: "mttbu",
            args: [
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_spr() & 0x3f9) == 0x210 {
        *out = ParsedIns {
            mnemonic: "mtibatu",
            args: [
                Argument::OpaqueU(OpaqueU(ins.field_spr_bat() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_spr() & 0x3f9) == 0x211 {
        *out = ParsedIns {
            mnemonic: "mtibatl",
            args: [
                Argument::OpaqueU(OpaqueU(ins.field_spr_bat() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_spr() & 0x3f9) == 0x218 {
        *out = ParsedIns {
            mnemonic: "mtdbatu",
            args: [
                Argument::OpaqueU(OpaqueU(ins.field_spr_bat() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_spr() & 0x3f9) == 0x219 {
        *out = ParsedIns {
            mnemonic: "mtdbatl",
            args: [
                Argument::OpaqueU(OpaqueU(ins.field_spr_bat() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    basic_mtspr(out, ins)
}
fn basic_mtsr(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "mtsr",
        args: [
            Argument::SR(SR(ins.field_sr() as _)),
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_mtsrd(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "mtsrd",
        args: [
            Argument::SR(SR(ins.field_sr() as _)),
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_mtsrdin(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "mtsrdin",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_mtsrin(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "mtsrin",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_mulhd(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["mulhd", "mulhd."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_mulhdu(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["mulhdu", "mulhdu."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_mulhw(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["mulhw", "mulhw."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_mulhwu(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["mulhwu", "mulhwu."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_mulld(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 4] = ["mulld", "mulldo", "mulld.", "mulldo."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_oe() as usize
                | (ins.field_rc() as usize) << 1],
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_mullw(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 4] = ["mullw", "mullwo", "mullw.", "mullwo."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_oe() as usize
                | (ins.field_rc() as usize) << 1],
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_nand(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["nand", "nand."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_neg(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 4] = ["neg", "nego", "neg.", "nego."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_oe() as usize
                | (ins.field_rc() as usize) << 1],
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_nor(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["nor", "nor."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_or(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["or", "or."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn simplified_or(out: &mut ParsedIns, ins: Ins) {
    if ins.field_rb() == ins.field_rs() {
        *out = {
            const MODIFIERS: [&str; 2] = ["mr", "mr."];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_rc() as usize],
                args: [
                    Argument::GPR(GPR(ins.field_ra() as _)),
                    Argument::GPR(GPR(ins.field_rs() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    basic_or(out, ins)
}
fn basic_orc(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["orc", "orc."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_slbia(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "slbia",
        args: EMPTY_ARGS,
    };
}
fn basic_slbie(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "slbie",
        args: [
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_sld(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["sld", "sld."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_slw(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["slw", "slw."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_srad(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["srad", "srad."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_sradi(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["sradi", "sradi."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::OpaqueU(OpaqueU(ins.field_sh() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_sraw(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["sraw", "sraw."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_srawi(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["srawi", "srawi."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::OpaqueU(OpaqueU(ins.field_sh() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_srd(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["srd", "srd."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_srw(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["srw", "srw."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_stbux(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stbux",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stbx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stbx",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stdcx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stdcx",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stdux(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stdux",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stdx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stdx",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stfdux(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stfdux",
        args: [
            Argument::FPR(FPR(ins.field_frs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stfdx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stfdx",
        args: [
            Argument::FPR(FPR(ins.field_frs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stfiwx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stfiwx",
        args: [
            Argument::FPR(FPR(ins.field_frs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stfsux(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stfsux",
        args: [
            Argument::FPR(FPR(ins.field_frs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stfsx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stfsx",
        args: [
            Argument::FPR(FPR(ins.field_frs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_sthbrx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "sthbrx",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_sthux(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "sthux",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_sthx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "sthx",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stswi(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stswi",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::OpaqueU(OpaqueU(ins.field_nb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stswx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stswx",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stwbrx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stwbrx",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stwcx_(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stwcx.",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stwux(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stwux",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stwx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stwx",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_subf(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 4] = ["subf", "subfo", "subf.", "subfo."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_oe() as usize
                | (ins.field_rc() as usize) << 1],
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_subfc(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 4] = ["subfc", "subfco", "subfc.", "subfco."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_oe() as usize
                | (ins.field_rc() as usize) << 1],
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_subfe(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 4] = ["subfe", "subfeo", "subfe.", "subfeo."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_oe() as usize
                | (ins.field_rc() as usize) << 1],
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_subfme(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 4] = ["subfme", "subfmeo", "subfme.", "subfmeo."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_oe() as usize
                | (ins.field_rc() as usize) << 1],
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_subfze(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 4] = ["subfze", "subfzeo", "subfze.", "subfzeo."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_oe() as usize
                | (ins.field_rc() as usize) << 1],
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_sync(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "sync",
        args: EMPTY_ARGS,
    };
}
fn basic_td(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "td",
        args: [
            Argument::OpaqueU(OpaqueU(ins.field_to() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_tlbie(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "tlbie",
        args: [
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_tlbsync(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "tlbsync",
        args: EMPTY_ARGS,
    };
}
fn basic_tw(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "tw",
        args: [
            Argument::OpaqueU(OpaqueU(ins.field_to() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn simplified_tw(out: &mut ParsedIns, ins: Ins) {
    if ins.field_to() == 0x4 {
        *out = ParsedIns {
            mnemonic: "tweq",
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_to() == 0x5 {
        *out = ParsedIns {
            mnemonic: "twlge",
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_to() == 0x1f && ins.field_ra() == 0x0 && ins.field_rb() == 0x0 {
        *out = ParsedIns {
            mnemonic: "trap",
            args: EMPTY_ARGS,
        };
        return;
    }
    basic_tw(out, ins)
}
fn basic_xor(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["xor", "xor."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_dss(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["dss", "dssa"];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_a() as usize],
            args: [
                Argument::OpaqueU(OpaqueU(ins.field_strm() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_dst(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["dst", "dstt"];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_t() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::OpaqueU(OpaqueU(ins.field_strm() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_dstst(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["dstst", "dststt"];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_t() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::OpaqueU(OpaqueU(ins.field_strm() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_lvebx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lvebx",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lvehx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lvehx",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lvewx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lvewx",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lvsl(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lvsl",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lvsr(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lvsr",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lvx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lvx",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lvxl(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lvxl",
        args: [
            Argument::GPR(GPR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stvebx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stvebx",
        args: [
            Argument::GPR(GPR(ins.field_vs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stvehx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stvehx",
        args: [
            Argument::GPR(GPR(ins.field_vs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stvewx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stvewx",
        args: [
            Argument::GPR(GPR(ins.field_vs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stvx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stvx",
        args: [
            Argument::GPR(GPR(ins.field_vs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stvxl(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stvxl",
        args: [
            Argument::GPR(GPR(ins.field_vs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lwz(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lwz",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lwzu(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lwzu",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lbz(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lbz",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lbzu(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lbzu",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stw(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stw",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stwu(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stwu",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stb(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stb",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stbu(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stbu",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lhz(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lhz",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lhzu(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lhzu",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lha(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lha",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lhau(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lhau",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_sth(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "sth",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_sthu(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "sthu",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lmw(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lmw",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stmw(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stmw",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lfs(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lfs",
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lfsu(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lfsu",
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lfd(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lfd",
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lfdu(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lfdu",
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stfs(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stfs",
        args: [
            Argument::FPR(FPR(ins.field_frs() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stfsu(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stfsu",
        args: [
            Argument::FPR(FPR(ins.field_frs() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stfd(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stfd",
        args: [
            Argument::FPR(FPR(ins.field_frs() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stfdu(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stfdu",
        args: [
            Argument::FPR(FPR(ins.field_frs() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_ld(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "ld",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_ldu(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "ldu",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lwa(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lwa",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_fadds(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["fadds", "fadds."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_fra() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_fdivs(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["fdivs", "fdivs."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_fra() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_fmadds(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["fmadds", "fmadds."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_fra() as _)),
                Argument::FPR(FPR(ins.field_frc() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
            ],
        }
    };
}
fn basic_fmsubs(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["fmsubs", "fmsubs."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_fra() as _)),
                Argument::FPR(FPR(ins.field_frc() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
            ],
        }
    };
}
fn basic_fmuls(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["fmuls", "fmuls."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_fra() as _)),
                Argument::FPR(FPR(ins.field_frc() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_fnmadds(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["fnmadds", "fnmadds."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_fra() as _)),
                Argument::FPR(FPR(ins.field_frc() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
            ],
        }
    };
}
fn basic_fnmsubs(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["fnmsubs", "fnmsubs."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_fra() as _)),
                Argument::FPR(FPR(ins.field_frc() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
            ],
        }
    };
}
fn basic_fres(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["fres", "fres."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_fsubs(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["fsubs", "fsubs."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_fra() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_std(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "std",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stdu(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stdu",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_fabs(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["fabs", "fabs."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_fadd(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["fadd", "fadd."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_fra() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_fcfid(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["fcfid", "fcfid."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_fcmpo(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "fcmpo",
        args: [
            Argument::CRField(CRField(ins.field_crfd() as _)),
            Argument::FPR(FPR(ins.field_fra() as _)),
            Argument::FPR(FPR(ins.field_frb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_fcmpu(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "fcmpu",
        args: [
            Argument::CRField(CRField(ins.field_crfd() as _)),
            Argument::FPR(FPR(ins.field_fra() as _)),
            Argument::FPR(FPR(ins.field_frb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_fctid(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["fctid", "fctid."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_fctidz(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["fctidz", "fctidz."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_fctiw(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["fctiw", "fctiw."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_fctiwz(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["fctiwz", "fctiwz."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_fdiv(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["fdiv", "fdiv."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_fra() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_fmadd(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["fmadd", "fmadd."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_fra() as _)),
                Argument::FPR(FPR(ins.field_frc() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
            ],
        }
    };
}
fn basic_fmr(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["fmr", "fmr."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_fmsub(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["fmsub", "fmsub."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_fra() as _)),
                Argument::FPR(FPR(ins.field_frc() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
            ],
        }
    };
}
fn basic_fmul(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["fmul", "fmul."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_fra() as _)),
                Argument::FPR(FPR(ins.field_frc() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_fnabs(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["fnabs", "fnabs."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_fneg(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["fneg", "fneg."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_fnmadd(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["fnmadd", "fnmadd."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_fra() as _)),
                Argument::FPR(FPR(ins.field_frc() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
            ],
        }
    };
}
fn basic_fnmsub(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["fnmsub", "fnmsub."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_fra() as _)),
                Argument::FPR(FPR(ins.field_frc() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
            ],
        }
    };
}
fn basic_frsp(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["frsp", "frsp."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_frsqrte(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["frsqrte", "frsqrte."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_fsel(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["fsel", "fsel."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_fra() as _)),
                Argument::FPR(FPR(ins.field_frc() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
            ],
        }
    };
}
fn basic_fsub(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["fsub", "fsub."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_fra() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_mcrfs(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "mcrfs",
        args: [
            Argument::CRField(CRField(ins.field_crfd() as _)),
            Argument::CRField(CRField(ins.field_crfs() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_mffs(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["mffs", "mffs."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_mtfsb0(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["mtfsb0", "mtfsb0."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::CRBit(CRBit(ins.field_crbd() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_mtfsb1(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["mtfsb1", "mtfsb1."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::CRBit(CRBit(ins.field_crbd() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_mtfsf(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["mtfsf", "mtfsf."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::OpaqueU(OpaqueU(ins.field_mtfsf_fm() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_mtfsfi(out: &mut ParsedIns, ins: Ins) {
    *out = {
        const MODIFIERS: [&str; 2] = ["mtfsfi", "mtfsfi."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::CRField(CRField(ins.field_crfd() as _)),
                Argument::OpaqueU(OpaqueU(ins.field_mtfsf_imm() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn mnemonic_illegal(out: &mut ParsedIns, _ins: Ins) {
    *out = ParsedIns::new();
}
static BASIC_MNEMONICS: [MnemonicFunction; 512] = [
    basic_tdwi,
    basic_twi,
    basic_dcbz_l,
    basic_mfvscr,
    basic_mtvscr,
    basic_vaddcuw,
    basic_vaddfp,
    basic_vaddsbs,
    basic_vaddshs,
    basic_vaddsws,
    basic_vaddubm,
    basic_vaddubs,
    basic_vadduhm,
    basic_vadduhs,
    basic_vadduwm,
    basic_vadduws,
    basic_vand,
    basic_vandc,
    basic_vavgsb,
    basic_vavgsh,
    basic_vavgsw,
    basic_vavgub,
    basic_vavguh,
    basic_vavguw,
    basic_vcfsx,
    basic_vcfux,
    basic_vcmpbfp,
    basic_vcmpeqfp,
    basic_vcmpequb,
    basic_vcmpequh,
    basic_vcmpequw,
    basic_vcmpgefp,
    basic_vcmpgtfp,
    basic_vcmpgtsb,
    basic_vcmpgtsh,
    basic_vcmpgtsw,
    basic_vcmpgtub,
    basic_vcmpgtuh,
    basic_vcmpgtuw,
    basic_vctsxs,
    basic_vctuxs,
    basic_vexptefp,
    basic_vlogefp,
    basic_vmaddfp,
    basic_vmaxfp,
    basic_vmaxsb,
    basic_vmaxsh,
    basic_vmaxsw,
    basic_vmaxub,
    basic_vmaxuh,
    basic_vmaxuw,
    basic_vmhaddshs,
    basic_vmhraddshs,
    basic_vminfp,
    basic_vminsb,
    basic_vminsh,
    basic_vminsw,
    basic_vminub,
    basic_vminuh,
    basic_vminuw,
    basic_vmladduhm,
    basic_vmrghb,
    basic_vmrghh,
    basic_vmrghw,
    basic_vmrglb,
    basic_vmrglh,
    basic_vmrglw,
    basic_vmsummbm,
    basic_vmsumshm,
    basic_vmsumshs,
    basic_vmsumubm,
    basic_vmsumuhm,
    basic_vmsumuhs,
    basic_vmulesb,
    basic_vmulesh,
    basic_vmuleub,
    basic_vmuleuh,
    basic_vmulosb,
    basic_vmulosh,
    basic_vmuloub,
    basic_vmulouh,
    basic_vnmsubfp,
    basic_vnor,
    basic_vor,
    basic_vperm,
    basic_vpkpx,
    basic_vpkshss,
    basic_vpkshus,
    basic_vpkswss,
    basic_vpkswus,
    basic_vpkuhum,
    basic_vpkuhus,
    basic_vpkuwum,
    basic_vpkuwus,
    basic_vrefp,
    basic_vrfim,
    basic_vrfin,
    basic_vrfip,
    basic_vrfiz,
    basic_vrlb,
    basic_vrlh,
    basic_vrlw,
    basic_vrsqrtefp,
    basic_vsel,
    basic_vsl,
    basic_vslb,
    basic_vsldoi,
    basic_vslh,
    basic_vslo,
    basic_vslw,
    basic_vspltb,
    basic_vsplth,
    basic_vspltisb,
    basic_vspltish,
    basic_vspltisw,
    basic_vspltw,
    basic_vsr,
    basic_vsrab,
    basic_vsrah,
    basic_vsraw,
    basic_vsrb,
    basic_vsrh,
    basic_vsro,
    basic_vsrw,
    basic_vsubcuw,
    basic_vsubfp,
    basic_vsubsbs,
    basic_vsubshs,
    basic_vsubsws,
    basic_vsububm,
    basic_vsububs,
    basic_vsubuhm,
    basic_vsubuhs,
    basic_vsubuwm,
    basic_vsubuws,
    basic_vsumsws,
    basic_vsum2sws,
    basic_vsum4sbs,
    basic_vsum4shs,
    basic_vsum4ubs,
    basic_vupkhpx,
    basic_vupkhsb,
    basic_vupkhsh,
    basic_vupklpx,
    basic_vupklsb,
    basic_vupklsh,
    basic_vxor,
    basic_mulli,
    basic_subfic,
    basic_cmpli,
    basic_cmpi,
    basic_addic,
    basic_addic_,
    basic_addi,
    basic_addis,
    basic_bc,
    basic_sc,
    basic_b,
    basic_bcctr,
    basic_bclr,
    basic_crand,
    basic_crandc,
    basic_creqv,
    basic_crnand,
    basic_crnor,
    basic_cror,
    basic_crorc,
    basic_crxor,
    basic_isync,
    basic_mcrf,
    basic_rfi,
    basic_rfid,
    basic_rlwimi,
    basic_rlwinm,
    basic_rlwnm,
    basic_ori,
    basic_oris,
    basic_xori,
    basic_xoris,
    basic_andi_,
    basic_andis_,
    basic_rldcl,
    basic_rldcr,
    basic_rldic,
    basic_rldicl,
    basic_rldicr,
    basic_rldimi,
    basic_add,
    basic_addc,
    basic_adde,
    basic_addme,
    basic_addze,
    basic_and,
    basic_andc,
    basic_cmp,
    basic_cmpl,
    basic_cntlzd,
    basic_cntlzw,
    basic_dcbf,
    basic_dcbi,
    basic_dcbst,
    basic_dcbt,
    basic_dcbtst,
    basic_dcbz,
    basic_divd,
    basic_divdu,
    basic_divw,
    basic_divwu,
    basic_eciwx,
    basic_ecowx,
    basic_eieio,
    basic_eqv,
    basic_extsb,
    basic_extsh,
    basic_extsw,
    basic_icbi,
    basic_lbzux,
    basic_lbzx,
    basic_ldarx,
    basic_ldux,
    basic_ldx,
    basic_lfdux,
    basic_lfdx,
    basic_lfsux,
    basic_lfsx,
    basic_lhaux,
    basic_lhax,
    basic_lhbrx,
    basic_lhzux,
    basic_lhzx,
    basic_lswi,
    basic_lswx,
    basic_lwarx,
    basic_lwaux,
    basic_lwax,
    basic_lwbrx,
    basic_lwzux,
    basic_lwzx,
    basic_mcrxr,
    basic_mfcr,
    basic_mfmsr,
    basic_mfspr,
    basic_mfsr,
    basic_mfsrin,
    basic_mftb,
    basic_mtcrf,
    basic_mtmsr,
    basic_mtmsrd,
    basic_mtspr,
    basic_mtsr,
    basic_mtsrd,
    basic_mtsrdin,
    basic_mtsrin,
    basic_mulhd,
    basic_mulhdu,
    basic_mulhw,
    basic_mulhwu,
    basic_mulld,
    basic_mullw,
    basic_nand,
    basic_neg,
    basic_nor,
    basic_or,
    basic_orc,
    basic_slbia,
    basic_slbie,
    basic_sld,
    basic_slw,
    basic_srad,
    basic_sradi,
    basic_sraw,
    basic_srawi,
    basic_srd,
    basic_srw,
    basic_stbux,
    basic_stbx,
    basic_stdcx,
    basic_stdux,
    basic_stdx,
    basic_stfdux,
    basic_stfdx,
    basic_stfiwx,
    basic_stfsux,
    basic_stfsx,
    basic_sthbrx,
    basic_sthux,
    basic_sthx,
    basic_stswi,
    basic_stswx,
    basic_stwbrx,
    basic_stwcx_,
    basic_stwux,
    basic_stwx,
    basic_subf,
    basic_subfc,
    basic_subfe,
    basic_subfme,
    basic_subfze,
    basic_sync,
    basic_td,
    basic_tlbie,
    basic_tlbsync,
    basic_tw,
    basic_xor,
    basic_dss,
    basic_dst,
    basic_dstst,
    basic_lvebx,
    basic_lvehx,
    basic_lvewx,
    basic_lvsl,
    basic_lvsr,
    basic_lvx,
    basic_lvxl,
    basic_stvebx,
    basic_stvehx,
    basic_stvewx,
    basic_stvx,
    basic_stvxl,
    basic_lwz,
    basic_lwzu,
    basic_lbz,
    basic_lbzu,
    basic_stw,
    basic_stwu,
    basic_stb,
    basic_stbu,
    basic_lhz,
    basic_lhzu,
    basic_lha,
    basic_lhau,
    basic_sth,
    basic_sthu,
    basic_lmw,
    basic_stmw,
    basic_lfs,
    basic_lfsu,
    basic_lfd,
    basic_lfdu,
    basic_stfs,
    basic_stfsu,
    basic_stfd,
    basic_stfdu,
    basic_ld,
    basic_ldu,
    basic_lwa,
    basic_fadds,
    basic_fdivs,
    basic_fmadds,
    basic_fmsubs,
    basic_fmuls,
    basic_fnmadds,
    basic_fnmsubs,
    basic_fres,
    basic_fsubs,
    basic_std,
    basic_stdu,
    basic_fabs,
    basic_fadd,
    basic_fcfid,
    basic_fcmpo,
    basic_fcmpu,
    basic_fctid,
    basic_fctidz,
    basic_fctiw,
    basic_fctiwz,
    basic_fdiv,
    basic_fmadd,
    basic_fmr,
    basic_fmsub,
    basic_fmul,
    basic_fnabs,
    basic_fneg,
    basic_fnmadd,
    basic_fnmsub,
    basic_frsp,
    basic_frsqrte,
    basic_fsel,
    basic_fsub,
    basic_mcrfs,
    basic_mffs,
    basic_mtfsb0,
    basic_mtfsb1,
    basic_mtfsf,
    basic_mtfsfi,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
];
#[inline]
pub fn parse_basic(out: &mut ParsedIns, ins: Ins) {
    BASIC_MNEMONICS[ins.op as usize](out, ins)
}
static SIMPLIFIED_MNEMONICS: [MnemonicFunction; 512] = [
    basic_tdwi,
    simplified_twi,
    basic_dcbz_l,
    basic_mfvscr,
    basic_mtvscr,
    basic_vaddcuw,
    basic_vaddfp,
    basic_vaddsbs,
    basic_vaddshs,
    basic_vaddsws,
    basic_vaddubm,
    basic_vaddubs,
    basic_vadduhm,
    basic_vadduhs,
    basic_vadduwm,
    basic_vadduws,
    basic_vand,
    basic_vandc,
    basic_vavgsb,
    basic_vavgsh,
    basic_vavgsw,
    basic_vavgub,
    basic_vavguh,
    basic_vavguw,
    basic_vcfsx,
    basic_vcfux,
    basic_vcmpbfp,
    basic_vcmpeqfp,
    basic_vcmpequb,
    basic_vcmpequh,
    basic_vcmpequw,
    basic_vcmpgefp,
    basic_vcmpgtfp,
    basic_vcmpgtsb,
    basic_vcmpgtsh,
    basic_vcmpgtsw,
    basic_vcmpgtub,
    basic_vcmpgtuh,
    basic_vcmpgtuw,
    basic_vctsxs,
    basic_vctuxs,
    basic_vexptefp,
    basic_vlogefp,
    basic_vmaddfp,
    basic_vmaxfp,
    basic_vmaxsb,
    basic_vmaxsh,
    basic_vmaxsw,
    basic_vmaxub,
    basic_vmaxuh,
    basic_vmaxuw,
    basic_vmhaddshs,
    basic_vmhraddshs,
    basic_vminfp,
    basic_vminsb,
    basic_vminsh,
    basic_vminsw,
    basic_vminub,
    basic_vminuh,
    basic_vminuw,
    basic_vmladduhm,
    basic_vmrghb,
    basic_vmrghh,
    basic_vmrghw,
    basic_vmrglb,
    basic_vmrglh,
    basic_vmrglw,
    basic_vmsummbm,
    basic_vmsumshm,
    basic_vmsumshs,
    basic_vmsumubm,
    basic_vmsumuhm,
    basic_vmsumuhs,
    basic_vmulesb,
    basic_vmulesh,
    basic_vmuleub,
    basic_vmuleuh,
    basic_vmulosb,
    basic_vmulosh,
    basic_vmuloub,
    basic_vmulouh,
    basic_vnmsubfp,
    basic_vnor,
    basic_vor,
    basic_vperm,
    basic_vpkpx,
    basic_vpkshss,
    basic_vpkshus,
    basic_vpkswss,
    basic_vpkswus,
    basic_vpkuhum,
    basic_vpkuhus,
    basic_vpkuwum,
    basic_vpkuwus,
    basic_vrefp,
    basic_vrfim,
    basic_vrfin,
    basic_vrfip,
    basic_vrfiz,
    basic_vrlb,
    basic_vrlh,
    basic_vrlw,
    basic_vrsqrtefp,
    basic_vsel,
    basic_vsl,
    basic_vslb,
    basic_vsldoi,
    basic_vslh,
    basic_vslo,
    basic_vslw,
    basic_vspltb,
    basic_vsplth,
    basic_vspltisb,
    basic_vspltish,
    basic_vspltisw,
    basic_vspltw,
    basic_vsr,
    basic_vsrab,
    basic_vsrah,
    basic_vsraw,
    basic_vsrb,
    basic_vsrh,
    basic_vsro,
    basic_vsrw,
    basic_vsubcuw,
    basic_vsubfp,
    basic_vsubsbs,
    basic_vsubshs,
    basic_vsubsws,
    basic_vsububm,
    basic_vsububs,
    basic_vsubuhm,
    basic_vsubuhs,
    basic_vsubuwm,
    basic_vsubuws,
    basic_vsumsws,
    basic_vsum2sws,
    basic_vsum4sbs,
    basic_vsum4shs,
    basic_vsum4ubs,
    basic_vupkhpx,
    basic_vupkhsb,
    basic_vupkhsh,
    basic_vupklpx,
    basic_vupklsb,
    basic_vupklsh,
    basic_vxor,
    basic_mulli,
    basic_subfic,
    simplified_cmpli,
    simplified_cmpi,
    simplified_addic,
    simplified_addic_,
    simplified_addi,
    simplified_addis,
    simplified_bc,
    basic_sc,
    basic_b,
    simplified_bcctr,
    simplified_bclr,
    basic_crand,
    basic_crandc,
    simplified_creqv,
    basic_crnand,
    simplified_crnor,
    simplified_cror,
    basic_crorc,
    simplified_crxor,
    basic_isync,
    basic_mcrf,
    basic_rfi,
    basic_rfid,
    basic_rlwimi,
    simplified_rlwinm,
    simplified_rlwnm,
    simplified_ori,
    basic_oris,
    basic_xori,
    basic_xoris,
    basic_andi_,
    basic_andis_,
    basic_rldcl,
    basic_rldcr,
    basic_rldic,
    basic_rldicl,
    basic_rldicr,
    basic_rldimi,
    basic_add,
    basic_addc,
    basic_adde,
    basic_addme,
    basic_addze,
    basic_and,
    basic_andc,
    simplified_cmp,
    simplified_cmpl,
    basic_cntlzd,
    basic_cntlzw,
    basic_dcbf,
    basic_dcbi,
    basic_dcbst,
    basic_dcbt,
    basic_dcbtst,
    basic_dcbz,
    basic_divd,
    basic_divdu,
    basic_divw,
    basic_divwu,
    basic_eciwx,
    basic_ecowx,
    basic_eieio,
    basic_eqv,
    basic_extsb,
    basic_extsh,
    basic_extsw,
    basic_icbi,
    basic_lbzux,
    basic_lbzx,
    basic_ldarx,
    basic_ldux,
    basic_ldx,
    basic_lfdux,
    basic_lfdx,
    basic_lfsux,
    basic_lfsx,
    basic_lhaux,
    basic_lhax,
    basic_lhbrx,
    basic_lhzux,
    basic_lhzx,
    basic_lswi,
    basic_lswx,
    basic_lwarx,
    basic_lwaux,
    basic_lwax,
    basic_lwbrx,
    basic_lwzux,
    basic_lwzx,
    basic_mcrxr,
    basic_mfcr,
    basic_mfmsr,
    simplified_mfspr,
    basic_mfsr,
    basic_mfsrin,
    basic_mftb,
    basic_mtcrf,
    basic_mtmsr,
    basic_mtmsrd,
    simplified_mtspr,
    basic_mtsr,
    basic_mtsrd,
    basic_mtsrdin,
    basic_mtsrin,
    basic_mulhd,
    basic_mulhdu,
    basic_mulhw,
    basic_mulhwu,
    basic_mulld,
    basic_mullw,
    basic_nand,
    basic_neg,
    basic_nor,
    simplified_or,
    basic_orc,
    basic_slbia,
    basic_slbie,
    basic_sld,
    basic_slw,
    basic_srad,
    basic_sradi,
    basic_sraw,
    basic_srawi,
    basic_srd,
    basic_srw,
    basic_stbux,
    basic_stbx,
    basic_stdcx,
    basic_stdux,
    basic_stdx,
    basic_stfdux,
    basic_stfdx,
    basic_stfiwx,
    basic_stfsux,
    basic_stfsx,
    basic_sthbrx,
    basic_sthux,
    basic_sthx,
    basic_stswi,
    basic_stswx,
    basic_stwbrx,
    basic_stwcx_,
    basic_stwux,
    basic_stwx,
    basic_subf,
    basic_subfc,
    basic_subfe,
    basic_subfme,
    basic_subfze,
    basic_sync,
    basic_td,
    basic_tlbie,
    basic_tlbsync,
    simplified_tw,
    basic_xor,
    basic_dss,
    basic_dst,
    basic_dstst,
    basic_lvebx,
    basic_lvehx,
    basic_lvewx,
    basic_lvsl,
    basic_lvsr,
    basic_lvx,
    basic_lvxl,
    basic_stvebx,
    basic_stvehx,
    basic_stvewx,
    basic_stvx,
    basic_stvxl,
    basic_lwz,
    basic_lwzu,
    basic_lbz,
    basic_lbzu,
    basic_stw,
    basic_stwu,
    basic_stb,
    basic_stbu,
    basic_lhz,
    basic_lhzu,
    basic_lha,
    basic_lhau,
    basic_sth,
    basic_sthu,
    basic_lmw,
    basic_stmw,
    basic_lfs,
    basic_lfsu,
    basic_lfd,
    basic_lfdu,
    basic_stfs,
    basic_stfsu,
    basic_stfd,
    basic_stfdu,
    basic_ld,
    basic_ldu,
    basic_lwa,
    basic_fadds,
    basic_fdivs,
    basic_fmadds,
    basic_fmsubs,
    basic_fmuls,
    basic_fnmadds,
    basic_fnmsubs,
    basic_fres,
    basic_fsubs,
    basic_std,
    basic_stdu,
    basic_fabs,
    basic_fadd,
    basic_fcfid,
    basic_fcmpo,
    basic_fcmpu,
    basic_fctid,
    basic_fctidz,
    basic_fctiw,
    basic_fctiwz,
    basic_fdiv,
    basic_fmadd,
    basic_fmr,
    basic_fmsub,
    basic_fmul,
    basic_fnabs,
    basic_fneg,
    basic_fnmadd,
    basic_fnmsub,
    basic_frsp,
    basic_frsqrte,
    basic_fsel,
    basic_fsub,
    basic_mcrfs,
    basic_mffs,
    basic_mtfsb0,
    basic_mtfsb1,
    basic_mtfsf,
    basic_mtfsfi,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
];
#[inline]
pub fn parse_simplified(out: &mut ParsedIns, ins: Ins) {
    SIMPLIFIED_MNEMONICS[ins.op as usize](out, ins)
}
type DefsUsesFunction = fn(&mut Arguments, Ins);
fn uses_tdwi(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_twi(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_dcbz_l(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_mfvscr(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_mtvscr(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vaddcuw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vaddcuw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vaddfp(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vaddfp(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vaddsbs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vaddsbs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vaddshs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vaddshs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vaddsws(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vaddsws(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vaddubm(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vaddubm(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vaddubs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vaddubs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vadduhm(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vadduhm(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vadduhs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vadduhs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vadduwm(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vadduwm(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vadduws(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vadduws(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vand(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vand(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vandc(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vandc(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vavgsb(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vavgsb(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vavgsh(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vavgsh(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vavgsw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vavgsw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vavgub(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vavgub(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vavguh(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vavguh(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vavguw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vavguw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vcfsx(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vcfsx(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::Uimm(Uimm(ins.field_vuimm() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vcfux(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vcfux(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::Uimm(Uimm(ins.field_vuimm() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vcmpbfp(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vcmpbfp(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vcmpeqfp(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vcmpeqfp(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vcmpequb(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vcmpequb(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vcmpequh(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vcmpequh(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vcmpequw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vcmpequw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vcmpgefp(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vcmpgefp(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vcmpgtfp(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vcmpgtfp(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vcmpgtsb(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vcmpgtsb(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vcmpgtsh(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vcmpgtsh(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vcmpgtsw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vcmpgtsw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vcmpgtub(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vcmpgtub(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vcmpgtuh(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vcmpgtuh(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vcmpgtuw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vcmpgtuw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vctsxs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vctsxs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::Uimm(Uimm(ins.field_vuimm() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vctuxs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vctuxs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::Uimm(Uimm(ins.field_vuimm() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vexptefp(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vexptefp(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vlogefp(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vlogefp(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vmaddfp(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vmaddfp(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vc() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn defs_vmaxfp(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vmaxfp(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vmaxsb(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vmaxsb(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vmaxsh(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vmaxsh(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vmaxsw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vmaxsw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vmaxub(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vmaxub(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vmaxuh(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vmaxuh(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vmaxuw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vmaxuw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vmhaddshs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vmhaddshs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::GPR(GPR(ins.field_vc() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn defs_vmhraddshs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vmhraddshs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::GPR(GPR(ins.field_vc() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn defs_vminfp(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vminfp(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vminsb(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vminsb(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vminsh(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vminsh(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vminsw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vminsw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vminub(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vminub(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vminuh(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vminuh(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vminuw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vminuw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vmladduhm(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vmladduhm(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::GPR(GPR(ins.field_vc() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn defs_vmrghb(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vmrghb(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vmrghh(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vmrghh(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vmrghw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vmrghw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vmrglb(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vmrglb(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vmrglh(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vmrglh(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vmrglw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vmrglw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vmsummbm(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vmsummbm(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::GPR(GPR(ins.field_vc() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn defs_vmsumshm(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vmsumshm(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::GPR(GPR(ins.field_vc() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn defs_vmsumshs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vmsumshs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::GPR(GPR(ins.field_vc() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn defs_vmsumubm(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vmsumubm(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::GPR(GPR(ins.field_vc() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn defs_vmsumuhm(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vmsumuhm(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::GPR(GPR(ins.field_vc() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn defs_vmsumuhs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vmsumuhs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::GPR(GPR(ins.field_vc() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn defs_vmulesb(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vmulesb(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vmulesh(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vmulesh(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vmuleub(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vmuleub(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vmuleuh(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vmuleuh(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vmulosb(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vmulosb(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vmulosh(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vmulosh(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vmuloub(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vmuloub(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vmulouh(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vmulouh(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vnmsubfp(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vnmsubfp(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vc() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn defs_vnor(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vnor(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vor(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vor(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vperm(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vperm(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::GPR(GPR(ins.field_vc() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn defs_vpkpx(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vpkpx(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vpkshss(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vpkshss(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vpkshus(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vpkshus(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vpkswss(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vpkswss(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vpkswus(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vpkswus(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vpkuhum(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vpkuhum(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vpkuhus(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vpkuhus(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vpkuwum(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vpkuwum(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vpkuwus(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vpkuwus(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vrefp(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vrefp(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vrfim(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vrfim(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vrfin(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vrfin(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vrfip(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vrfip(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vrfiz(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vrfiz(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vrlb(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vrlb(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vrlh(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vrlh(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vrlw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vrlw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vrsqrtefp(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vrsqrtefp(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vsel(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vsel(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::GPR(GPR(ins.field_vc() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn defs_vsl(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vsl(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vslb(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vslb(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vsldoi(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vsldoi(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::OpaqueU(OpaqueU(ins.field_shb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn defs_vslh(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vslh(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vslo(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vslo(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vslw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vslw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vspltb(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vspltb(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::Uimm(Uimm(ins.field_vuimm() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vsplth(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vsplth(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::Uimm(Uimm(ins.field_vuimm() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vspltisb(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vspltisb(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::Simm(Simm(ins.field_vsimm() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vspltish(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vspltish(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::Simm(Simm(ins.field_vsimm() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vspltisw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vspltisw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::Simm(Simm(ins.field_vsimm() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vspltw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vspltw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::Uimm(Uimm(ins.field_vuimm() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vsr(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vsr(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vsrab(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vsrab(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vsrah(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vsrah(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vsraw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vsraw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vsrb(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vsrb(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vsrh(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vsrh(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vsro(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vsro(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vsrw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vsrw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vsubcuw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vsubcuw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vsubfp(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vsubfp(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vsubsbs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vsubsbs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vsubshs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vsubshs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vsubsws(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vsubsws(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vsububm(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vsububm(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vsububs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vsububs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vsubuhm(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vsubuhm(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vsubuhs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vsubuhs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vsubuwm(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vsubuwm(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vsubuws(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vsubuws(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vsumsws(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vsumsws(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vsum2sws(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vsum2sws(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vsum4sbs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vsum4sbs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vsum4shs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vsum4shs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vsum4ubs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vsum4ubs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vupkhpx(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vupkhpx(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vupkhsb(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vupkhsb(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vupkhsh(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vupkhsh(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vupklpx(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vupklpx(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vupklsb(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vupklsb(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vupklsh(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vupklsh(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_vxor(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vxor(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_va() as _)),
        Argument::GPR(GPR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_mulli(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_mulli(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_subfic(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_subfic(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_cmpli(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRField(CRField(ins.field_crfd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_cmpli(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_cmpi(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRField(CRField(ins.field_crfd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_cmpi(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_addic(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_addic(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_addic_(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_addic_(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_addi(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_addi(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_addis(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_addis(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_crand(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRBit(CRBit(ins.field_crbd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_crand(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRBit(CRBit(ins.field_crba() as _)),
        Argument::CRBit(CRBit(ins.field_crbb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_crandc(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRBit(CRBit(ins.field_crbd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_crandc(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRBit(CRBit(ins.field_crba() as _)),
        Argument::CRBit(CRBit(ins.field_crbb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_creqv(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRBit(CRBit(ins.field_crbd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_creqv(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRBit(CRBit(ins.field_crba() as _)),
        Argument::CRBit(CRBit(ins.field_crbb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_crnand(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRBit(CRBit(ins.field_crbd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_crnand(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRBit(CRBit(ins.field_crba() as _)),
        Argument::CRBit(CRBit(ins.field_crbb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_crnor(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRBit(CRBit(ins.field_crbd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_crnor(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRBit(CRBit(ins.field_crba() as _)),
        Argument::CRBit(CRBit(ins.field_crbb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_cror(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRBit(CRBit(ins.field_crbd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_cror(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRBit(CRBit(ins.field_crba() as _)),
        Argument::CRBit(CRBit(ins.field_crbb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_crorc(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRBit(CRBit(ins.field_crbd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_crorc(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRBit(CRBit(ins.field_crba() as _)),
        Argument::CRBit(CRBit(ins.field_crbb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_crxor(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRBit(CRBit(ins.field_crbd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_crxor(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRBit(CRBit(ins.field_crba() as _)),
        Argument::CRBit(CRBit(ins.field_crbb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_mcrf(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRField(CRField(ins.field_crfd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_mcrf(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRField(CRField(ins.field_crfs() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_rlwimi(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_rlwimi(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::OpaqueU(OpaqueU(ins.field_sh() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn defs_rlwinm(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_rlwinm(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::OpaqueU(OpaqueU(ins.field_sh() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_rlwnm(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_rlwnm(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_ori(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_ori(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_oris(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_oris(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_xori(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_xori(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_xoris(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_xoris(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_andi_(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_andi_(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_andis_(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_andis_(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_rldcl(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_rldcl(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_rldcr(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_rldcr(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_rldic(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_rldic(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::OpaqueU(OpaqueU(ins.field_sh() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_rldicl(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_rldicl(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::OpaqueU(OpaqueU(ins.field_sh() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_rldicr(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_rldicr(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::OpaqueU(OpaqueU(ins.field_sh() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_rldimi(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_rldimi(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::OpaqueU(OpaqueU(ins.field_sh() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn defs_add(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_add(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_addc(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_addc(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_adde(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_adde(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_addme(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_addme(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_addze(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_addze(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_and(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_and(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_andc(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_andc(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_cmp(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRField(CRField(ins.field_crfd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_cmp(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_cmpl(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRField(CRField(ins.field_crfd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_cmpl(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_cntlzd(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_cntlzd(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_cntlzw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_cntlzw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_dcbf(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_dcbi(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_dcbst(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_dcbt(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_dcbtst(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_dcbz(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_divd(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_divd(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_divdu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_divdu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_divw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_divw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_divwu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_divwu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_eciwx(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_eciwx(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_ecowx(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn defs_eqv(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_eqv(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_extsb(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_extsb(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_extsh(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_extsh(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_extsw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_extsw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_icbi(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lbzux(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lbzux(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lbzx(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lbzx(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_ldarx(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_ldarx(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_ldux(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_ldux(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_ldx(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_ldx(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lfdux(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lfdux(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lfdx(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lfdx(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lfsux(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lfsux(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lfsx(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lfsx(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lhaux(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lhaux(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lhax(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lhax(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lhbrx(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lhbrx(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lhzux(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lhzux(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lhzx(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lhzx(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lswi(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lswi(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lswx(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lswx(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lwarx(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lwarx(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lwaux(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lwaux(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lwax(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lwax(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lwbrx(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lwbrx(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lwzux(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lwzux(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lwzx(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lwzx(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_mcrxr(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRField(CRField(ins.field_crfd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_mfcr(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_mfmsr(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_mfspr(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_mfsr(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_mfsrin(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_mfsrin(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_mftb(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_mtcrf(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_mtmsr(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_mtmsrd(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_mtspr(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_mtsr(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_mtsrd(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_mtsrdin(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_mtsrin(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_mulhd(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_mulhd(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_mulhdu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_mulhdu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_mulhw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_mulhw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_mulhwu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_mulhwu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_mulld(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_mulld(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_mullw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_mullw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_nand(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_nand(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_neg(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_neg(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_nor(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_nor(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_or(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_or(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_orc(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_orc(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_slbie(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_sld(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_sld(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_slw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_slw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_srad(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_srad(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_sradi(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_sradi(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_sraw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_sraw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_srawi(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_srawi(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_srd(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_srd(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_srw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_srw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_stbux(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_stbux(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn uses_stbx(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn uses_stdcx(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn defs_stdux(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_stdux(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn defs_stdx(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_stdx(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn defs_stfdux(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_stfdux(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frs() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn uses_stfdx(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frs() as _)),
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn uses_stfiwx(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frs() as _)),
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn defs_stfsux(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_stfsux(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frs() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn uses_stfsx(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frs() as _)),
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn uses_sthbrx(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn defs_sthux(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_sthux(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn uses_sthx(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn uses_stswi(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_stswx(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn uses_stwbrx(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn uses_stwcx_(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn defs_stwux(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_stwux(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn uses_stwx(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn defs_subf(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_subf(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_subfc(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_subfc(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_subfe(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_subfe(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_subfme(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_subfme(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_subfze(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_subfze(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_td(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_tlbie(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_tw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_xor(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_xor(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_dss(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::OpaqueU(OpaqueU(ins.field_strm() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_dst(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::OpaqueU(OpaqueU(ins.field_strm() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn uses_dstst(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::OpaqueU(OpaqueU(ins.field_strm() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn defs_lvebx(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lvebx(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lvehx(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lvehx(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lvewx(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lvewx(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lvsl(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lvsl(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lvsr(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lvsr(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lvx(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lvx(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lvxl(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lvxl(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_stvebx(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_stvehx(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_stvewx(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_stvx(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_stvxl(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lwz(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lwz(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::Offset(Offset(ins.field_offset() as _)),
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lwzu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lwzu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::Offset(Offset(ins.field_offset() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lbz(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lbz(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::Offset(Offset(ins.field_offset() as _)),
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lbzu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lbzu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::Offset(Offset(ins.field_offset() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_stw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_stwu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_stwu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_stb(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_stbu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_stbu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lhz(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lhz(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::Offset(Offset(ins.field_offset() as _)),
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lhzu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lhzu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::Offset(Offset(ins.field_offset() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lha(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lha(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::Offset(Offset(ins.field_offset() as _)),
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lhau(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lhau(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::Offset(Offset(ins.field_offset() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_sth(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_sthu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_sthu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lmw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lmw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::Offset(Offset(ins.field_offset() as _)),
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_stmw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lfs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lfs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::Offset(Offset(ins.field_offset() as _)),
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lfsu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lfsu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::Offset(Offset(ins.field_offset() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lfd(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lfd(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::Offset(Offset(ins.field_offset() as _)),
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lfdu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lfdu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::Offset(Offset(ins.field_offset() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_stfs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frs() as _)),
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_stfsu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_stfsu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frs() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_stfd(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frs() as _)),
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_stfdu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_stfdu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frs() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_ld(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_ld(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::Offset(Offset(ins.field_offset() as _)),
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_ldu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_ldu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::Offset(Offset(ins.field_offset() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lwa(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lwa(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::Offset(Offset(ins.field_offset() as _)),
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_fadds(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_fadds(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_fra() as _)),
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_fdivs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_fdivs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_fra() as _)),
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_fmadds(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_fmadds(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_fra() as _)),
        Argument::FPR(FPR(ins.field_frc() as _)),
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn defs_fmsubs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_fmsubs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_fra() as _)),
        Argument::FPR(FPR(ins.field_frc() as _)),
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn defs_fmuls(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_fmuls(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_fra() as _)),
        Argument::FPR(FPR(ins.field_frc() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_fnmadds(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_fnmadds(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_fra() as _)),
        Argument::FPR(FPR(ins.field_frc() as _)),
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn defs_fnmsubs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_fnmsubs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_fra() as _)),
        Argument::FPR(FPR(ins.field_frc() as _)),
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn defs_fres(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_fres(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_fsubs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_fsubs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_fra() as _)),
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_std(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_stdu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_stdu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_fabs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_fabs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_fadd(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_fadd(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_fra() as _)),
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_fcfid(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_fcfid(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_fcmpo(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRField(CRField(ins.field_crfd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_fcmpo(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_fra() as _)),
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_fcmpu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRField(CRField(ins.field_crfd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_fcmpu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_fra() as _)),
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_fctid(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_fctid(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_fctidz(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_fctidz(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_fctiw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_fctiw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_fctiwz(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_fctiwz(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_fdiv(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_fdiv(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_fra() as _)),
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_fmadd(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_fmadd(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_fra() as _)),
        Argument::FPR(FPR(ins.field_frc() as _)),
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn defs_fmr(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_fmr(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_fmsub(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_fmsub(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_fra() as _)),
        Argument::FPR(FPR(ins.field_frc() as _)),
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn defs_fmul(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_fmul(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_fra() as _)),
        Argument::FPR(FPR(ins.field_frc() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_fnabs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_fnabs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_fneg(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_fneg(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_fnmadd(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_fnmadd(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_fra() as _)),
        Argument::FPR(FPR(ins.field_frc() as _)),
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn defs_fnmsub(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_fnmsub(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_fra() as _)),
        Argument::FPR(FPR(ins.field_frc() as _)),
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn defs_frsp(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_frsp(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_frsqrte(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_frsqrte(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_fsel(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_fsel(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_fra() as _)),
        Argument::FPR(FPR(ins.field_frc() as _)),
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn defs_fsub(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_fsub(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_fra() as _)),
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_mcrfs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRField(CRField(ins.field_crfd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_mcrfs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRField(CRField(ins.field_crfs() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_mffs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_mtfsb0(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRBit(CRBit(ins.field_crbd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_mtfsb1(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRBit(CRBit(ins.field_crbd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_mtfsf(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_mtfsfi(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRField(CRField(ins.field_crfd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_uses_empty(out: &mut Arguments, _ins: Ins) {
    *out = EMPTY_ARGS;
}
static DEFS_FUNCTIONS: [DefsUsesFunction; 512] = [
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_mfvscr,
    defs_uses_empty,
    defs_vaddcuw,
    defs_vaddfp,
    defs_vaddsbs,
    defs_vaddshs,
    defs_vaddsws,
    defs_vaddubm,
    defs_vaddubs,
    defs_vadduhm,
    defs_vadduhs,
    defs_vadduwm,
    defs_vadduws,
    defs_vand,
    defs_vandc,
    defs_vavgsb,
    defs_vavgsh,
    defs_vavgsw,
    defs_vavgub,
    defs_vavguh,
    defs_vavguw,
    defs_vcfsx,
    defs_vcfux,
    defs_vcmpbfp,
    defs_vcmpeqfp,
    defs_vcmpequb,
    defs_vcmpequh,
    defs_vcmpequw,
    defs_vcmpgefp,
    defs_vcmpgtfp,
    defs_vcmpgtsb,
    defs_vcmpgtsh,
    defs_vcmpgtsw,
    defs_vcmpgtub,
    defs_vcmpgtuh,
    defs_vcmpgtuw,
    defs_vctsxs,
    defs_vctuxs,
    defs_vexptefp,
    defs_vlogefp,
    defs_vmaddfp,
    defs_vmaxfp,
    defs_vmaxsb,
    defs_vmaxsh,
    defs_vmaxsw,
    defs_vmaxub,
    defs_vmaxuh,
    defs_vmaxuw,
    defs_vmhaddshs,
    defs_vmhraddshs,
    defs_vminfp,
    defs_vminsb,
    defs_vminsh,
    defs_vminsw,
    defs_vminub,
    defs_vminuh,
    defs_vminuw,
    defs_vmladduhm,
    defs_vmrghb,
    defs_vmrghh,
    defs_vmrghw,
    defs_vmrglb,
    defs_vmrglh,
    defs_vmrglw,
    defs_vmsummbm,
    defs_vmsumshm,
    defs_vmsumshs,
    defs_vmsumubm,
    defs_vmsumuhm,
    defs_vmsumuhs,
    defs_vmulesb,
    defs_vmulesh,
    defs_vmuleub,
    defs_vmuleuh,
    defs_vmulosb,
    defs_vmulosh,
    defs_vmuloub,
    defs_vmulouh,
    defs_vnmsubfp,
    defs_vnor,
    defs_vor,
    defs_vperm,
    defs_vpkpx,
    defs_vpkshss,
    defs_vpkshus,
    defs_vpkswss,
    defs_vpkswus,
    defs_vpkuhum,
    defs_vpkuhus,
    defs_vpkuwum,
    defs_vpkuwus,
    defs_vrefp,
    defs_vrfim,
    defs_vrfin,
    defs_vrfip,
    defs_vrfiz,
    defs_vrlb,
    defs_vrlh,
    defs_vrlw,
    defs_vrsqrtefp,
    defs_vsel,
    defs_vsl,
    defs_vslb,
    defs_vsldoi,
    defs_vslh,
    defs_vslo,
    defs_vslw,
    defs_vspltb,
    defs_vsplth,
    defs_vspltisb,
    defs_vspltish,
    defs_vspltisw,
    defs_vspltw,
    defs_vsr,
    defs_vsrab,
    defs_vsrah,
    defs_vsraw,
    defs_vsrb,
    defs_vsrh,
    defs_vsro,
    defs_vsrw,
    defs_vsubcuw,
    defs_vsubfp,
    defs_vsubsbs,
    defs_vsubshs,
    defs_vsubsws,
    defs_vsububm,
    defs_vsububs,
    defs_vsubuhm,
    defs_vsubuhs,
    defs_vsubuwm,
    defs_vsubuws,
    defs_vsumsws,
    defs_vsum2sws,
    defs_vsum4sbs,
    defs_vsum4shs,
    defs_vsum4ubs,
    defs_vupkhpx,
    defs_vupkhsb,
    defs_vupkhsh,
    defs_vupklpx,
    defs_vupklsb,
    defs_vupklsh,
    defs_vxor,
    defs_mulli,
    defs_subfic,
    defs_cmpli,
    defs_cmpi,
    defs_addic,
    defs_addic_,
    defs_addi,
    defs_addis,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_crand,
    defs_crandc,
    defs_creqv,
    defs_crnand,
    defs_crnor,
    defs_cror,
    defs_crorc,
    defs_crxor,
    defs_uses_empty,
    defs_mcrf,
    defs_uses_empty,
    defs_uses_empty,
    defs_rlwimi,
    defs_rlwinm,
    defs_rlwnm,
    defs_ori,
    defs_oris,
    defs_xori,
    defs_xoris,
    defs_andi_,
    defs_andis_,
    defs_rldcl,
    defs_rldcr,
    defs_rldic,
    defs_rldicl,
    defs_rldicr,
    defs_rldimi,
    defs_add,
    defs_addc,
    defs_adde,
    defs_addme,
    defs_addze,
    defs_and,
    defs_andc,
    defs_cmp,
    defs_cmpl,
    defs_cntlzd,
    defs_cntlzw,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_divd,
    defs_divdu,
    defs_divw,
    defs_divwu,
    defs_eciwx,
    defs_uses_empty,
    defs_uses_empty,
    defs_eqv,
    defs_extsb,
    defs_extsh,
    defs_extsw,
    defs_uses_empty,
    defs_lbzux,
    defs_lbzx,
    defs_ldarx,
    defs_ldux,
    defs_ldx,
    defs_lfdux,
    defs_lfdx,
    defs_lfsux,
    defs_lfsx,
    defs_lhaux,
    defs_lhax,
    defs_lhbrx,
    defs_lhzux,
    defs_lhzx,
    defs_lswi,
    defs_lswx,
    defs_lwarx,
    defs_lwaux,
    defs_lwax,
    defs_lwbrx,
    defs_lwzux,
    defs_lwzx,
    defs_mcrxr,
    defs_mfcr,
    defs_mfmsr,
    defs_mfspr,
    defs_mfsr,
    defs_mfsrin,
    defs_mftb,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_mulhd,
    defs_mulhdu,
    defs_mulhw,
    defs_mulhwu,
    defs_mulld,
    defs_mullw,
    defs_nand,
    defs_neg,
    defs_nor,
    defs_or,
    defs_orc,
    defs_uses_empty,
    defs_uses_empty,
    defs_sld,
    defs_slw,
    defs_srad,
    defs_sradi,
    defs_sraw,
    defs_srawi,
    defs_srd,
    defs_srw,
    defs_stbux,
    defs_uses_empty,
    defs_uses_empty,
    defs_stdux,
    defs_stdx,
    defs_stfdux,
    defs_uses_empty,
    defs_uses_empty,
    defs_stfsux,
    defs_uses_empty,
    defs_uses_empty,
    defs_sthux,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_stwux,
    defs_uses_empty,
    defs_subf,
    defs_subfc,
    defs_subfe,
    defs_subfme,
    defs_subfze,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_xor,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_lvebx,
    defs_lvehx,
    defs_lvewx,
    defs_lvsl,
    defs_lvsr,
    defs_lvx,
    defs_lvxl,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_lwz,
    defs_lwzu,
    defs_lbz,
    defs_lbzu,
    defs_uses_empty,
    defs_stwu,
    defs_uses_empty,
    defs_stbu,
    defs_lhz,
    defs_lhzu,
    defs_lha,
    defs_lhau,
    defs_uses_empty,
    defs_sthu,
    defs_lmw,
    defs_uses_empty,
    defs_lfs,
    defs_lfsu,
    defs_lfd,
    defs_lfdu,
    defs_uses_empty,
    defs_stfsu,
    defs_uses_empty,
    defs_stfdu,
    defs_ld,
    defs_ldu,
    defs_lwa,
    defs_fadds,
    defs_fdivs,
    defs_fmadds,
    defs_fmsubs,
    defs_fmuls,
    defs_fnmadds,
    defs_fnmsubs,
    defs_fres,
    defs_fsubs,
    defs_uses_empty,
    defs_stdu,
    defs_fabs,
    defs_fadd,
    defs_fcfid,
    defs_fcmpo,
    defs_fcmpu,
    defs_fctid,
    defs_fctidz,
    defs_fctiw,
    defs_fctiwz,
    defs_fdiv,
    defs_fmadd,
    defs_fmr,
    defs_fmsub,
    defs_fmul,
    defs_fnabs,
    defs_fneg,
    defs_fnmadd,
    defs_fnmsub,
    defs_frsp,
    defs_frsqrte,
    defs_fsel,
    defs_fsub,
    defs_mcrfs,
    defs_mffs,
    defs_mtfsb0,
    defs_mtfsb1,
    defs_uses_empty,
    defs_mtfsfi,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
];
#[inline]
pub fn parse_defs(out: &mut Arguments, ins: Ins) {
    DEFS_FUNCTIONS[ins.op as usize](out, ins)
}
static USES_FUNCTIONS: [DefsUsesFunction; 512] = [
    uses_tdwi,
    uses_twi,
    uses_dcbz_l,
    defs_uses_empty,
    uses_mtvscr,
    uses_vaddcuw,
    uses_vaddfp,
    uses_vaddsbs,
    uses_vaddshs,
    uses_vaddsws,
    uses_vaddubm,
    uses_vaddubs,
    uses_vadduhm,
    uses_vadduhs,
    uses_vadduwm,
    uses_vadduws,
    uses_vand,
    uses_vandc,
    uses_vavgsb,
    uses_vavgsh,
    uses_vavgsw,
    uses_vavgub,
    uses_vavguh,
    uses_vavguw,
    uses_vcfsx,
    uses_vcfux,
    uses_vcmpbfp,
    uses_vcmpeqfp,
    uses_vcmpequb,
    uses_vcmpequh,
    uses_vcmpequw,
    uses_vcmpgefp,
    uses_vcmpgtfp,
    uses_vcmpgtsb,
    uses_vcmpgtsh,
    uses_vcmpgtsw,
    uses_vcmpgtub,
    uses_vcmpgtuh,
    uses_vcmpgtuw,
    uses_vctsxs,
    uses_vctuxs,
    uses_vexptefp,
    uses_vlogefp,
    uses_vmaddfp,
    uses_vmaxfp,
    uses_vmaxsb,
    uses_vmaxsh,
    uses_vmaxsw,
    uses_vmaxub,
    uses_vmaxuh,
    uses_vmaxuw,
    uses_vmhaddshs,
    uses_vmhraddshs,
    uses_vminfp,
    uses_vminsb,
    uses_vminsh,
    uses_vminsw,
    uses_vminub,
    uses_vminuh,
    uses_vminuw,
    uses_vmladduhm,
    uses_vmrghb,
    uses_vmrghh,
    uses_vmrghw,
    uses_vmrglb,
    uses_vmrglh,
    uses_vmrglw,
    uses_vmsummbm,
    uses_vmsumshm,
    uses_vmsumshs,
    uses_vmsumubm,
    uses_vmsumuhm,
    uses_vmsumuhs,
    uses_vmulesb,
    uses_vmulesh,
    uses_vmuleub,
    uses_vmuleuh,
    uses_vmulosb,
    uses_vmulosh,
    uses_vmuloub,
    uses_vmulouh,
    uses_vnmsubfp,
    uses_vnor,
    uses_vor,
    uses_vperm,
    uses_vpkpx,
    uses_vpkshss,
    uses_vpkshus,
    uses_vpkswss,
    uses_vpkswus,
    uses_vpkuhum,
    uses_vpkuhus,
    uses_vpkuwum,
    uses_vpkuwus,
    uses_vrefp,
    uses_vrfim,
    uses_vrfin,
    uses_vrfip,
    uses_vrfiz,
    uses_vrlb,
    uses_vrlh,
    uses_vrlw,
    uses_vrsqrtefp,
    uses_vsel,
    uses_vsl,
    uses_vslb,
    uses_vsldoi,
    uses_vslh,
    uses_vslo,
    uses_vslw,
    uses_vspltb,
    uses_vsplth,
    uses_vspltisb,
    uses_vspltish,
    uses_vspltisw,
    uses_vspltw,
    uses_vsr,
    uses_vsrab,
    uses_vsrah,
    uses_vsraw,
    uses_vsrb,
    uses_vsrh,
    uses_vsro,
    uses_vsrw,
    uses_vsubcuw,
    uses_vsubfp,
    uses_vsubsbs,
    uses_vsubshs,
    uses_vsubsws,
    uses_vsububm,
    uses_vsububs,
    uses_vsubuhm,
    uses_vsubuhs,
    uses_vsubuwm,
    uses_vsubuws,
    uses_vsumsws,
    uses_vsum2sws,
    uses_vsum4sbs,
    uses_vsum4shs,
    uses_vsum4ubs,
    uses_vupkhpx,
    uses_vupkhsb,
    uses_vupkhsh,
    uses_vupklpx,
    uses_vupklsb,
    uses_vupklsh,
    uses_vxor,
    uses_mulli,
    uses_subfic,
    uses_cmpli,
    uses_cmpi,
    uses_addic,
    uses_addic_,
    uses_addi,
    uses_addis,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    uses_crand,
    uses_crandc,
    uses_creqv,
    uses_crnand,
    uses_crnor,
    uses_cror,
    uses_crorc,
    uses_crxor,
    defs_uses_empty,
    uses_mcrf,
    defs_uses_empty,
    defs_uses_empty,
    uses_rlwimi,
    uses_rlwinm,
    uses_rlwnm,
    uses_ori,
    uses_oris,
    uses_xori,
    uses_xoris,
    uses_andi_,
    uses_andis_,
    uses_rldcl,
    uses_rldcr,
    uses_rldic,
    uses_rldicl,
    uses_rldicr,
    uses_rldimi,
    uses_add,
    uses_addc,
    uses_adde,
    uses_addme,
    uses_addze,
    uses_and,
    uses_andc,
    uses_cmp,
    uses_cmpl,
    uses_cntlzd,
    uses_cntlzw,
    uses_dcbf,
    uses_dcbi,
    uses_dcbst,
    uses_dcbt,
    uses_dcbtst,
    uses_dcbz,
    uses_divd,
    uses_divdu,
    uses_divw,
    uses_divwu,
    uses_eciwx,
    uses_ecowx,
    defs_uses_empty,
    uses_eqv,
    uses_extsb,
    uses_extsh,
    uses_extsw,
    uses_icbi,
    uses_lbzux,
    uses_lbzx,
    uses_ldarx,
    uses_ldux,
    uses_ldx,
    uses_lfdux,
    uses_lfdx,
    uses_lfsux,
    uses_lfsx,
    uses_lhaux,
    uses_lhax,
    uses_lhbrx,
    uses_lhzux,
    uses_lhzx,
    uses_lswi,
    uses_lswx,
    uses_lwarx,
    uses_lwaux,
    uses_lwax,
    uses_lwbrx,
    uses_lwzux,
    uses_lwzx,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    uses_mfsrin,
    defs_uses_empty,
    uses_mtcrf,
    uses_mtmsr,
    uses_mtmsrd,
    uses_mtspr,
    uses_mtsr,
    uses_mtsrd,
    uses_mtsrdin,
    uses_mtsrin,
    uses_mulhd,
    uses_mulhdu,
    uses_mulhw,
    uses_mulhwu,
    uses_mulld,
    uses_mullw,
    uses_nand,
    uses_neg,
    uses_nor,
    uses_or,
    uses_orc,
    defs_uses_empty,
    uses_slbie,
    uses_sld,
    uses_slw,
    uses_srad,
    uses_sradi,
    uses_sraw,
    uses_srawi,
    uses_srd,
    uses_srw,
    uses_stbux,
    uses_stbx,
    uses_stdcx,
    uses_stdux,
    uses_stdx,
    uses_stfdux,
    uses_stfdx,
    uses_stfiwx,
    uses_stfsux,
    uses_stfsx,
    uses_sthbrx,
    uses_sthux,
    uses_sthx,
    uses_stswi,
    uses_stswx,
    uses_stwbrx,
    uses_stwcx_,
    uses_stwux,
    uses_stwx,
    uses_subf,
    uses_subfc,
    uses_subfe,
    uses_subfme,
    uses_subfze,
    defs_uses_empty,
    uses_td,
    uses_tlbie,
    defs_uses_empty,
    uses_tw,
    uses_xor,
    uses_dss,
    uses_dst,
    uses_dstst,
    uses_lvebx,
    uses_lvehx,
    uses_lvewx,
    uses_lvsl,
    uses_lvsr,
    uses_lvx,
    uses_lvxl,
    uses_stvebx,
    uses_stvehx,
    uses_stvewx,
    uses_stvx,
    uses_stvxl,
    uses_lwz,
    uses_lwzu,
    uses_lbz,
    uses_lbzu,
    uses_stw,
    uses_stwu,
    uses_stb,
    uses_stbu,
    uses_lhz,
    uses_lhzu,
    uses_lha,
    uses_lhau,
    uses_sth,
    uses_sthu,
    uses_lmw,
    uses_stmw,
    uses_lfs,
    uses_lfsu,
    uses_lfd,
    uses_lfdu,
    uses_stfs,
    uses_stfsu,
    uses_stfd,
    uses_stfdu,
    uses_ld,
    uses_ldu,
    uses_lwa,
    uses_fadds,
    uses_fdivs,
    uses_fmadds,
    uses_fmsubs,
    uses_fmuls,
    uses_fnmadds,
    uses_fnmsubs,
    uses_fres,
    uses_fsubs,
    uses_std,
    uses_stdu,
    uses_fabs,
    uses_fadd,
    uses_fcfid,
    uses_fcmpo,
    uses_fcmpu,
    uses_fctid,
    uses_fctidz,
    uses_fctiw,
    uses_fctiwz,
    uses_fdiv,
    uses_fmadd,
    uses_fmr,
    uses_fmsub,
    uses_fmul,
    uses_fnabs,
    uses_fneg,
    uses_fnmadd,
    uses_fnmsub,
    uses_frsp,
    uses_frsqrte,
    uses_fsel,
    uses_fsub,
    uses_mcrfs,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    uses_mtfsf,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
];
#[inline]
pub fn parse_uses(out: &mut Arguments, ins: Ins) {
    USES_FUNCTIONS[ins.op as usize](out, ins)
}
